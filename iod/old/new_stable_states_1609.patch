diff --git a/iod/src/MachineInstance.cpp b/iod/src/MachineInstance.cpp
index 98319af..a82ab0c 100644
--- a/iod/src/MachineInstance.cpp
+++ b/iod/src/MachineInstance.cpp
@@ -464,7 +464,14 @@ void MachineInstance::enqueue(const Package &package) {
 	setNeedsCheck();
 }
 
-bool MachineInstance::workToDo() { 
+bool MachineInstance::workToDo() {
+	if (!pending_events.empty()) { DBG_MSG << "!pending_events.empty()\n"; }
+	if (!SharedWorkSet::instance()->empty()) { DBG_MSG << "!SharedWorkSet::instance()->empty()\n"; }
+	if (!pending_state_change.empty()) { DBG_MSG << "!pending_state_change.empty()\n"; }
+	if (num_machines_with_work + total_machines_needing_check > 0) {
+		DBG_MSG << "num_machines_with_work + total_machines_needing_check > 0 ("
+			<< num_machines_with_work <<"," <<  total_machines_needing_check << ") > 0\n";
+	}
 	return !pending_events.empty() || !SharedWorkSet::instance()->empty() || !pending_state_change.empty()
 				|| num_machines_with_work + total_machines_needing_check > 0; 
 }
@@ -1394,19 +1401,17 @@ void MachineInstance::idle() {
 		}
 	}
 	while (!mail_queue.empty()){
-		if (!mail_queue.empty()) {
-			Package *p = 0;
-			{
-				boost::mutex::scoped_lock lock(q_mutex);
-				DBG_M_MESSAGING << _name << " has " <<  mail_queue.size() << " messages waiting\n";
-				p = new Package(mail_queue.front());
-				DBG_M_MESSAGING << _name << " found package " << *p << "\n";
-				mail_queue.pop_front();
-			}
-			if (p) {
-				handle(p->message, p->transmitter, p->needs_receipt);
-				delete p;
-			}
+		Package *p = 0;
+		{
+			boost::mutex::scoped_lock lock(q_mutex);
+			DBG_M_MESSAGING << _name << " has " <<  mail_queue.size() << " messages waiting\n";
+			p = new Package(mail_queue.front());
+			DBG_M_MESSAGING << _name << " found package " << *p << "\n";
+			mail_queue.pop_front();
+		}
+		if (p) {
+			handle(p->message, p->transmitter, p->needs_receipt);
+			delete p;
 		}
 	}
 	if (mail_queue.empty() && active_actions.empty()) has_work = false;
@@ -1454,6 +1459,7 @@ bool MachineInstance::processAll(uint32_t max_time, PollType which) {
 		if (mi) mi->setNeedsCheck();
 	}
 
+	num_machines_with_work = 0;
 	process_time = nowMicrosecs();
 	boost::recursive_mutex &mutex = SharedWorkSet::instance()->getMutex();
 	{
@@ -1462,7 +1468,11 @@ bool MachineInstance::processAll(uint32_t max_time, PollType which) {
 		while (busy_it != SharedWorkSet::instance()->end() ) {
 			MachineInstance *mi = *busy_it;
 			// is it possible for a non active machine to be executing a command?
-			if (mi->isActive() || mi->executingCommand()) mi->idle();
+			if (mi->isActive() || mi->executingCommand()) {
+				mi->idle();
+				if (mi->enabled() && !mi->executingCommand() && mi->mail_queue.empty())
+					++num_machines_with_work;
+			}
 			if (mi->state_machine && mi->state_machine->plugin)
 				mi->state_machine->plugin->poll_actions(mi);
 			if ( (mi->state_machine && mi->state_machine->plugin)
@@ -1553,7 +1563,6 @@ bool MachineInstance::processAll(uint32_t max_time, PollType which) {
 			if (m->state_machine && m->state_machine->plugin && m->state_machine->plugin->poll_actions) {
 				m->state_machine->plugin->poll_actions(m);
 				++total_plugins_with_work;
-				//TBD                ++num_machines_with_work;
 			}
 			if (m->hasWork() || !m->active_actions.empty()) {
 				DBG_ACTIONS << m->getName() << " has work\n";
@@ -1967,6 +1976,9 @@ bool MachineInstance::receives(const Message&m, Transmitter *from) {
 		// machines receive messages from objects they are listening to
 		if (std::find(listens.begin(), listens.end(), from) != listens.end()) {
 			DBG_M_MESSAGING << "Machine " << getName() << " receiving " << m << " from " << from->getName() << "\n";
+			if (m.getText() == "in.off_leave") {
+				int x = 1;
+			}
 			return true;
 		}
 	}
@@ -2086,7 +2098,7 @@ Action::Status MachineInstance::setState(const State &new_state, uint64_t author
 			}
 
 			txt = _name + "." + current_state.getName() + "_leave";
-			msg = Message(txt.c_str());
+			msg = Message(txt.c_str(), Message::LEAVEMSG);
 			std::set<MachineInstance*>::iterator dep_iter = depends.begin();
 			while (dep_iter != depends.end()) {
 				MachineInstance *dep = *dep_iter++;
@@ -2422,6 +2434,7 @@ Action *MachineInstance::findHandler(Message&m, Transmitter *from, bool response
 
 					// find state condition
 					bool found = false;
+					IfCommandAction *change_state_action = 0;
 					for (unsigned int ss_idx = 0; ss_idx < stable_states.size(); ++ss_idx) {
 						StableState &s = stable_states[ss_idx];
 						if (s.state_name == t.dest.getName()) {
@@ -2433,15 +2446,22 @@ Action *MachineInstance::findHandler(Message&m, Transmitter *from, bool response
 									ch.triggered = false;
 								}
 							}
-							MoveStateActionTemplate temp(_name.c_str(), t.dest.getName().c_str() );
-							MachineCommandTemplate mc("stable_state_test", "");
-							mc.setActionTemplate(&temp);
-							IfCommandActionTemplate ifcat(s.condition.predicate, &mc);
-							Action *a = new IfCommandAction(this, &ifcat);
-							this->push(a);
+							if (change_state_action == 0) {
+								MoveStateActionTemplate temp(_name.c_str(), t.dest.getName().c_str() );
+								MachineCommandTemplate mc("stable_state_test", "");
+								mc.setActionTemplate(&temp);
+								IfCommandActionTemplate ifcat(s.condition.predicate, &mc);
+								change_state_action = new IfCommandAction(this, &ifcat);
+							}
+							else {
+								// update the action to or with another condition
+								Predicate *p = new Predicate(change_state_action->condition.predicate, opOR,new Predicate(*s.condition.predicate) );
+								change_state_action->condition.predicate = p;
+							}
 							found = true;
 						}
 					}
+					if (change_state_action) this->enqueueAction(change_state_action);
 					// the CALL method waits for a response once the executed command is complete
 					// the response will be sent after the transition to the next state is done
 					if (response_required)
@@ -2782,12 +2802,7 @@ void MachineClass::enableAutomaticStateChanges() {
 }
 
 bool MachineClass::isStableState(State &state) {
-	std::vector<StableState>::iterator iter = stable_states.begin();
-	while (iter != stable_states.end()) {
-		StableState &s = *iter++;
-		if (s.state_name == state.getName()) return true;
-	}
-	return false;
+	return stable_state_xref.find(state.getName()) != stable_state_xref.end();
 }
 
 const State *MachineClass::findState(const char *seek) const {
@@ -3363,6 +3378,7 @@ bool MachineInstance::setStableState() {
 						DBG_AUTOSTATES << _name << ":" << id << " (" << current_state << ") should be in state " << s.state_name 
 							<< " due to condition: " << *s.condition.predicate << "\n";
 						char *sn = strdup(s.state_name.c_str());
+#if 0
 						MoveStateActionTemplate temp(_name.c_str(), sn );
 						state_change = new MoveStateAction(this, temp);
 						Action::Status action_status;
@@ -3376,6 +3392,10 @@ bool MachineInstance::setStableState() {
 						//if (action_status == Action::Complete || action_status == Action::Failed) {
 						state_change->release();
 						state_change = 0;
+#else
+						SetStateActionTemplate ssat(CStringHolder("SELF"), s.state_name );
+						enqueueAction(ssat.factory(this)); // execute this state change next time actions are processed
+#endif
 					}
 					else {
 						DBG_AUTOSTATES << " already there\n";
@@ -3386,20 +3406,20 @@ bool MachineInstance::setStableState() {
 							if (v.kind == Value::t_integer && v.iValue < next_timer)
 								next_timer = v.iValue;
 						}
-					}
-					if (s.uses_timer) {
-						DBG_SCHEDULER << _name << "[" << current_state.getName() 
+						if (s.subcondition_handlers) {
+							std::list<ConditionHandler>::iterator iter = s.subcondition_handlers->begin();
+							while (iter != s.subcondition_handlers->end()) {
+								ConditionHandler *ch = &(*iter++);
+								DBG_AUTOSTATES << "checking "
+								<< (*ch).condition.last_evaluation
+								<< "\n";
+								if (!ch->check(this)) ch->condition.predicate->scheduleTimerEvents(this);
+							}
+						}
+						if (s.uses_timer) {
+							DBG_SCHEDULER << _name << "[" << current_state.getName()
 							<< "] scheduling condition tests for state " << s.state_name << "\n";
-						s.condition.predicate->scheduleTimerEvents(this);
-					}
-					if (s.subcondition_handlers) {
-						std::list<ConditionHandler>::iterator iter = s.subcondition_handlers->begin();
-						while (iter != s.subcondition_handlers->end()) {
-							ConditionHandler *ch = &(*iter++);
-							DBG_AUTOSTATES << "checking "
-							<< (*ch).condition.last_evaluation
-							<< "\n";
-							if (!ch->check(this)) ch->condition.predicate->scheduleTimerEvents(this);
+							s.condition.predicate->scheduleTimerEvents(this);
 						}
 					}
 					found_match = true;
@@ -4116,16 +4136,6 @@ bool MachineInstance::hasState(const State &test) const {
 	if (state_machine) {
 		const State *s = state_machine->findState(test);
 		if (s) return true;
-
-		for (unsigned int ss_idx = 0; ss_idx < stable_states.size(); ++ss_idx) {
-			if (stable_states[ss_idx].state_name == test.getName()) {
-				// TBD remove this code
-				//all stable states should have been registered in the machines state table
-				// this test is to verify that
-				assert(false);
-				return true;
-			}
-		}
 	}
 	else {
 		char buf[100];
diff --git a/iod/src/MachineInstance.h b/iod/src/MachineInstance.h
index 1c4e4cd..9033029 100644
--- a/iod/src/MachineInstance.h
+++ b/iod/src/MachineInstance.h
@@ -165,7 +165,8 @@ public:
     std::vector<Parameter> locals;
     std::list<State> states;
     std::set<std::string> state_names;
-    std::vector<StableState> stable_states;
+	std::multimap<std::string, StableState> stable_state_xref;
+	std::vector<StableState> stable_states;
     std::multimap<std::string, MachineCommandTemplate*> commands;
     std::map<Message, MachineCommandTemplate*> enter_functions;
     std::multimap<Message, MachineCommandTemplate*> receives;
diff --git a/iod/src/ProcessingThread.cpp b/iod/src/ProcessingThread.cpp
index 076db3b..6965c1c 100644
--- a/iod/src/ProcessingThread.cpp
+++ b/iod/src/ProcessingThread.cpp
@@ -73,7 +73,7 @@ uint64_t clockwork_watchdog_timer = 0;
 
 extern void handle_io_sampling(uint64_t clock);
 
-#undef KEEPSTATS
+#define KEEPSTATS
 
 #define VERBOSE_DEBUG 0
 
@@ -599,12 +599,13 @@ void ProcessingThread::operator()()
 		int dynamic_poll_start_idx = 6;
 
 		char buf[100];
-		int poll_wait = 2 * internals->cycle_delay / 1000; // millisecs
-		machine_check_delay = internals->cycle_delay;
-		if (poll_wait == 0) poll_wait = 1;
+		int poll_wait = internals->cycle_delay / 1000; // millisecs
+		machine_check_delay = internals->cycle_delay / 5;
+		//if (poll_wait == 0) poll_wait = 1;
 		uint64_t curr_t = 0;
 		int systems_waiting = 0;
 		uint64_t last_sample_poll = 0;
+		bool machines_have_work;
 		while (!program_done)
 		{
 			curr_t = nowMicrosecs();
@@ -628,18 +629,26 @@ void ProcessingThread::operator()()
 			}
 
 			internals->process_manager.SetTime(curr_t);
+
+			machines_have_work = MachineInstance::workToDo();
+			if (machines_have_work)
+				poll_wait = 0;
+			else
+				poll_wait = internals->cycle_delay / 1000;
+
 			//if (Watchdog::anyTriggered(curr_t))
 			//	Watchdog::showTriggered(curr_t, true);
 			systems_waiting = pollZMQItems(poll_wait, items, 6 + internals->channel_sockets.size(), 
 				ecat_sync, resource_mgr, dispatch_sync, sched_sync, ecat_out);
 			//DBG_MSG << "loop. status: " << status << " proc: " << processing_state
 			//	<< " waiting: " << systems_waiting << "\n";
-			if (systems_waiting > 0) break;
+			if (systems_waiting > 0 || status == e_waiting) break;
 			if (IOComponent::updatesWaiting() || !io_work_queue.empty()) break;
-			if (curr_t - last_checked_machines > machine_check_delay && MachineInstance::workToDo() ) break;
-			if (!MachineInstance::pluginMachines().empty() && curr_t - last_checked_plugins >= 1000) break;
+			if (curr_t - last_checked_machines > machine_check_delay || machines_have_work ) break;
+			if (!MachineInstance::pluginMachines().empty()) break;  //&& curr_t - last_checked_plugins >= 1000) break;
 #ifdef KEEPSTATS
 			avg_poll_time.update();
+			usleep(10);
 			avg_poll_time.start();
 #endif
 		}
@@ -648,23 +657,29 @@ void ProcessingThread::operator()()
 		avg_poll_time.update();
 #endif
 
-#if 0
+#if 1
 		// debug code to work out what machines or systems tend to need processing
-		DBG_MSG << "handling activity " << systems_waiting
-			<< ( (items[internals->ECAT_ITEM].revents & ZMQ_POLLIN) ? " ethercat" : "")
-			<< ( (IOComponent::updatesWaiting()) ? " io components" : "")
-			<< ( (!io_work_queue.empty()) ? " io work" : "")
-			<< ( (curr_t - last_checked_machines > machine_check_delay) ? " machines" : "")
-			<< ( (curr_t - last_checked_plugins >= 10000) ? " plugins" : "")
-			<< "\n";
-		if (IOComponent::updatesWaiting()) {
-			extern std::set<IOComponent*> updatedComponentsOut;
-			std::set<IOComponent*>::iterator iter = updatedComponentsOut.begin();
-			while (iter != updatedComponentsOut.end()) std::cout << " " << (*iter++)->io_name;
-			std::cout << " \n";
+		{
+			if (systems_waiting > 0 || !io_work_queue.empty() || (machines_have_work || processing_state != eIdle || status != e_waiting) ) {
+				DBG_MSG << "handling activity. zmq: " << systems_waiting << " state: " << processing_state << " substate: " << status
+					<< ( (items[internals->ECAT_ITEM].revents & ZMQ_POLLIN) ? " ethercat" : "")
+					<< ( (IOComponent::updatesWaiting()) ? " io components" : "")
+					<< ( (!io_work_queue.empty()) ? " io work" : "")
+					<< ( (curr_t - last_checked_machines > machine_check_delay && machines_have_work) ? " machines" : "")
+					<< ( (!MachineInstance::pluginMachines().empty() && curr_t - last_checked_plugins >= 1000) ? " plugins" : "")
+					<< "\n";
+			}
+			if (IOComponent::updatesWaiting()) {
+				extern std::set<IOComponent*> updatedComponentsOut;
+				std::set<IOComponent*>::iterator iter = updatedComponentsOut.begin();
+				while (iter != updatedComponentsOut.end()) std::cout << " " << (*iter++)->io_name;
+				std::cout << " \n";
+			}
 		}
 #endif
 
+		if (systems_waiting == 0 && processing_state == eIdle && status == e_waiting)
+			int x = 1;
 		/* this loop prioritises ethercat processing but if a certain
 			number of ethercat cycles have been processed with no 
 			other activities being given time, we give other jobs
@@ -715,12 +730,15 @@ void ProcessingThread::operator()()
 		}
 		
 		if (program_done) break;
-		if (processing_state == eIdle && !MachineInstance::pluginMachines().empty() && curr_t - last_checked_plugins >= 1000) {
+		if (!MachineInstance::pluginMachines().empty()) {
+			if (processing_state == eIdle  && curr_t - last_checked_plugins >= 1000) {
 #ifdef KEEPSTATS
-			AutoStat stats(avg_plugin_time);
+				AutoStat stats(avg_plugin_time);
 #endif
-			MachineInstance::checkPluginStates();
+				MachineInstance::checkPluginStates();
+			}
 		}
+		else last_checked_plugins = curr_t;
 
 		if (status == e_waiting) {
 #ifdef KEEPSTATS
@@ -932,28 +950,35 @@ void ProcessingThread::operator()()
 			status = e_waiting_sched;
 		}
 
-		if (status == e_waiting && curr_t - last_checked_machines >= machine_check_delay && machine_is_ready && MachineInstance::workToDo() )
+		if (status == e_waiting && curr_t - last_checked_machines >= machine_check_delay && machine_is_ready && machines_have_work )
 		{
 
 			if (processing_state == eIdle)
 				processing_state = ePollingMachines;
-			if (processing_state == ePollingMachines)
-			{
-#ifdef KEEPSTATS
-				avg_clockwork_time.start();
-#endif
-				if (MachineInstance::processAll(150000, MachineInstance::NO_BUILTINS))
-					processing_state = eStableStates;
-			}
-			if (processing_state == eStableStates)
-			{
-				if (MachineInstance::checkStableStates(150000)) {
-					processing_state = eIdle;
-					last_checked_machines = curr_t; // check complete
+			const int num_loops = 1;
+			for (int i=0; i<num_loops; ++i) {
+				if (processing_state == ePollingMachines)
+				{
+	#ifdef KEEPSTATS
+					avg_clockwork_time.start();
+	#endif
+					if (MachineInstance::processAll(150000, MachineInstance::NO_BUILTINS))
+						processing_state = eStableStates;
+				}
+				if (processing_state == eStableStates)
+				{
+					if (MachineInstance::checkStableStates(150000)) {
+						if (i<num_loops-1)
+							processing_state = ePollingMachines;
+						else {
+							processing_state = eIdle;
+							last_checked_machines = curr_t; // check complete
 #ifdef KEEPSTATS
-					avg_clockwork_time.update();
+							avg_clockwork_time.update();
 #endif
-					;				}
+						}
+					}
+				}
 			}
 		}
 		if (status == e_waiting && machine_is_ready && !IOComponent::devices.empty() &&
diff --git a/iod/src/SetStateAction.cpp b/iod/src/SetStateAction.cpp
index ed9403e..518c841 100644
--- a/iod/src/SetStateAction.cpp
+++ b/iod/src/SetStateAction.cpp
@@ -50,11 +50,7 @@ Action::Status SetStateAction::executeStateChange(bool use_transitions)
 		MessageLog::instance()->add(msg);
 		error_str = msg;
 		status = Failed;
-		if (trigger) {
-			trigger->removeHolder(this);
-			trigger->release();
-			trigger = 0;
-		}
+		cleanupTrigger();
 		owner->stop(this);
 		return status; 
 	}
@@ -80,11 +76,7 @@ Action::Status SetStateAction::executeStateChange(bool use_transitions)
 					MessageLog::instance()->add(msg);
 					DBG_M_ACTIONS << error_str << "\n";
 					status = Failed;
-					if (trigger) {
-						trigger->removeHolder(this);
-						trigger->release();
-						trigger = 0;
-					}
+					cleanupTrigger();
 					owner->stop(this);
 					return status; 
 				}
@@ -98,11 +90,7 @@ Action::Status SetStateAction::executeStateChange(bool use_transitions)
 					error_str = msg;
 					DBG_M_ACTIONS << error_str << "\n";
 					status = Failed;
-					if (trigger) {
-						trigger->removeHolder(this);
-						trigger->release();
-						trigger = 0;
-					}
+					cleanupTrigger();
 					owner->stop(this);
 					return status;
 				}
@@ -122,12 +110,7 @@ Action::Status SetStateAction::executeStateChange(bool use_transitions)
 			if (txt == value.getName()) {
 				result_str = "OK";
 				status = Complete;
-				if (trigger) {
-					trigger->removeHolder(this);
-					trigger->release();
-					trigger = 0;
-				}
-				owner->stop(this);
+				cleanupTrigger();
 				return status;
 			}
 
@@ -160,11 +143,7 @@ Action::Status SetStateAction::executeStateChange(bool use_transitions)
 			if (machine->getCurrent() == value) {
 				DBG_M_ACTIONS << machine->getName() << " is already " << value << " skipping " << *this << "\n";
 				status = Complete;
-				if (trigger) {
-					trigger->removeHolder(this);
-					trigger->release();
-					trigger = 0;
-				}
+				cleanupTrigger();
 				owner->stop(this);
 				return status;
 			}
@@ -189,11 +168,7 @@ Action::Status SetStateAction::executeStateChange(bool use_transitions)
 								else
 									result_str = "OK";
 								if (status != Action::Running && status != Action::Suspended && owner->executingCommand() == this) {
-									if (trigger) {
-										trigger->removeHolder(this);
-										trigger->release();
-										trigger = 0;
-									}
+									cleanupTrigger();
 									owner->stop(this);
 								}
 								return status;
@@ -213,11 +188,7 @@ Action::Status SetStateAction::executeStateChange(bool use_transitions)
 				//DBG_M_ACTIONS << "SetStateAction didn't find a transition for " << machine->getCurrent() << " to " << value << "; manually setting\n";
 			}
 			status = machine->setState( value, authority );
-			if (trigger) {
-				trigger->removeHolder(this);
-				trigger->release();
-				trigger = 0;
-			}
+			cleanupTrigger();
 			if (status == Complete || status == Failed) {
 				owner->stop(this);
 			}
@@ -231,6 +202,23 @@ Action::Status SetStateAction::executeStateChange(bool use_transitions)
 					value.getName().c_str() );
 				error_str = (const char *)buf;
 			}
+			if (status == Complete) {
+				owner->stop(this);
+				State value(new_state.sValue.c_str());
+				if (owner->getStateMachine()->isStableState(value)) {
+					std::multimap<std::string, StableState>::iterator iter(owner->getStateMachine()->stable_state_xref.find(new_state.sValue));
+					while (iter != owner->getStateMachine()->stable_state_xref.end()) {
+						const std::pair<std::string, StableState> &node(*iter++);
+						if (node.second.state_name != new_state.sValue) break;
+						if (node.second.uses_timer) {
+							DBG_SCHEDULER << owner->fullName() << "[" << owner->current_state.getName()
+							<< "] scheduling condition tests for state " << node.second.state_name << "\n";
+							node.second.condition.predicate->scheduleTimerEvents(owner);
+						}
+					}
+				}
+
+			}
 			return status;
 		}
 #if 0
@@ -272,9 +260,7 @@ Action::Status SetStateAction::checkComplete() {
 			DBG_M_MESSAGING << owner->getName() << " Set State Action " << *this << " has triggered, cleaning up\n";
 			NB_MSG << owner->getName() << " Set State Action " << *this << " has triggered, cleaning up\n";
 			status = Complete;
-			trigger->removeHolder(this);
-			trigger->release();
-			trigger = 0;
+			cleanupTrigger();
 			owner->stop(this);
 			return status;
 		}
@@ -291,9 +277,7 @@ Action::Status SetStateAction::checkComplete() {
 				status = Complete;
 				if (trigger) {
 					if (trigger->enabled() && !trigger->fired()) trigger->fire();
-					trigger->removeHolder(this);
-					trigger->release();
-					trigger = 0;
+					cleanupTrigger();
 				}
 				owner->stop(this);
 				return status;
@@ -308,9 +292,7 @@ Action::Status SetStateAction::checkComplete() {
 				status = Complete;
 				if (trigger) {
 					if (trigger->enabled() && !trigger->fired()) trigger->fire();
-					trigger->removeHolder(this);
-					trigger->release();
-					trigger = 0;
+					cleanupTrigger();
 				}
 				owner->stop(this);
 				return status;
