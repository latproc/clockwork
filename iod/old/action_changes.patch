diff --git a/iod/src/Action.cpp b/iod/src/Action.cpp
index bebcd63..ca0e18a 100644
--- a/iod/src/Action.cpp
+++ b/iod/src/Action.cpp
@@ -20,7 +20,41 @@ Trigger *Trigger::release() {
 	return 0;
 }
 
-void Action::setTrigger(Trigger *t) { if (trigger == t) return; if (trigger) trigger->release(); trigger = t->retain(); }
+Trigger::Trigger()
+: name("inactive"), seen(false), is_active(false), owner(0), deleted(false), refs(1) {}
+Trigger::Trigger(const std::string &n)
+: name(n), seen(false), is_active(true), owner(0), deleted(false), refs(1) {}
+Trigger::Trigger(const Trigger &o)
+: name(o.name), seen(o.seen), is_active(o.is_active), owner(o.owner), deleted(false), refs(1) {}
+Trigger &Trigger::operator=(const Trigger &o) {
+	name = o.name;
+	seen = o.seen;
+	is_active = o.is_active;
+	owner = o.owner;
+	// note: refs does not change
+	return *this;
+}
+
+void Trigger::setOwner(TriggerOwner *new_owner) { owner = new_owner; }
+bool Trigger::enabled() const { return is_active; }
+bool Trigger::fired() const { return seen; }
+void Trigger::fire() { if (seen) return; seen = true; if (owner) owner->triggerFired(this); }
+void Trigger::reset() { seen = false; }
+void Trigger::enable() { is_active = true; }
+void Trigger::disable() { is_active = false; }
+const std::string& Trigger::getName() const { return name; }
+bool Trigger::matches(const std::string &event) {
+	return is_active && event == name;
+}
+const std::string &Trigger::getName() { return name; }
+
+void Action::setTrigger(Trigger *t) {
+	if (trigger == t) return;
+	if (trigger) {
+		assert(trigger->fired());
+		trigger->release();
+	}
+	trigger = t->retain(); }
 Trigger *Action::getTrigger() const { return trigger; }
 void Action::disableTrigger() { if (trigger) trigger->disable(); }
 
diff --git a/iod/src/Action.h b/iod/src/Action.h
index ccff896..30173fc 100644
--- a/iod/src/Action.h
+++ b/iod/src/Action.h
@@ -48,33 +48,24 @@ struct TriggerOwner {
 
 class Trigger {
 public:
-	Trigger() : name("inactive"), seen(false), is_active(false), owner(0), deleted(false), refs(1) {}
-	Trigger(const std::string &n) : name(n), seen(false), is_active(true), owner(0), deleted(false), refs(1) {}
-	Trigger(const Trigger &o) : name(o.name), seen(o.seen), is_active(o.is_active), owner(o.owner), deleted(false), refs(1) {}
-	Trigger &operator=(const Trigger &o) { 
-		name = o.name;
-		seen = o.seen;
-		is_active = o.is_active;
-        owner = o.owner;
-        // note: refs does not change
-		return *this;
-	}
+	Trigger();
+	Trigger(const std::string &n);
+	Trigger(const Trigger &o);
+	Trigger &operator=(const Trigger &o);
 	virtual ~Trigger();
 	Trigger*retain();
 	virtual Trigger *release();
 	
-    void setOwner(TriggerOwner *new_owner) { owner = new_owner; }
-	bool enabled() const { return is_active; }
-	bool fired() const { return seen; }
-	void fire() { if (seen) return; seen = true; if (owner) owner->triggerFired(this); }
-	void reset() { seen = false; }
-	void enable() { is_active = true; }
-	void disable() { is_active = false; }
-	const std::string& getName() const { return name; }
-	bool matches(const std::string &event) { 
-		return is_active && event == name;
-	}
-	const std::string &getName() { return name; }
+	void setOwner(TriggerOwner *new_owner);
+	bool enabled() const;
+	bool fired() const;
+	void fire();
+	void reset();
+	void enable();
+	void disable();
+	const std::string& getName() const;
+	bool matches(const std::string &event);
+	const std::string &getName();
 	
 protected:
 	std::string name;
diff --git a/iod/src/CallMethodAction.cpp b/iod/src/CallMethodAction.cpp
index 9bd0446..7394f0a 100644
--- a/iod/src/CallMethodAction.cpp
+++ b/iod/src/CallMethodAction.cpp
@@ -62,8 +62,14 @@ Action::Status CallMethodAction::run() {
 		return status;
 	}
 	else {
-		setTrigger(owner->setupTrigger(target_machine->getName(), message.get(), "_done"));
-		owner->sendMessageToReceiver(new Message(message.get()), target_machine, true);
+		if (!getTrigger() || getTrigger()->fired()) {
+			setTrigger(owner->setupTrigger(target_machine->getName(), message.get(), "_done"));
+			owner->sendMessageToReceiver(new Message(message.get()), target_machine, true);
+		}
+		else {
+			status = New;
+			return status;
+		}
 	}
 	status = Action::Running;
 	return status;
@@ -71,6 +77,11 @@ Action::Status CallMethodAction::run() {
 
 Action::Status CallMethodAction::checkComplete() {
     if (status == Complete || status == Failed) return status;
+	if (status == New && (!getTrigger() || getTrigger()->fired()) ) {
+		setTrigger(owner->setupTrigger(target_machine->getName(), message.get(), "_done"));
+		owner->sendMessageToReceiver(new Message(message.get()), target_machine, true);
+		status = Action::Running;
+	}
 	if ( trigger->fired()) {
 		status = Action::Complete;
 		owner->stop(this);
@@ -81,7 +92,6 @@ Action::Status CallMethodAction::checkComplete() {
 
 std::ostream &CallMethodAction::operator<<(std::ostream &out) const {
     return out << "CallMethodAction " << message.get() << " on " << target.get()
-	<< ((trigger && !trigger->fired() ) ? " Waiting for trigger to fire " : (!trigger) ? " no trigger set " : "trigger fired")
-	<< "\n";
+	<< ((trigger && !trigger->fired() ) ? " Waiting for trigger to fire " : (!trigger) ? " no trigger set " : "trigger fired");
 }
 		
diff --git a/iod/src/IODCommands.cpp b/iod/src/IODCommands.cpp
index 5b60894..5dc0418 100644
--- a/iod/src/IODCommands.cpp
+++ b/iod/src/IODCommands.cpp
@@ -476,10 +476,10 @@ bool IODCommandResume::run(std::vector<Value> &params) {
 
 bool IODCommandList::run(std::vector<Value> &params) {
 	std::ostringstream ss;
-	std::map<std::string, MachineInstance*>::const_iterator iter = machines.begin();
-	while (iter != machines.end()) {
-		MachineInstance *m = (*iter).second;
-		ss << (m->getName()) << " " << m->_type;
+	std::list< MachineInstance*>::const_iterator iter = MachineInstance::begin();
+	while (iter != MachineInstance::end()) {
+		MachineInstance *m = *iter;
+		ss << (m->fullName()) << " " << m->_type;
 		if (m->_type == "POINT") ss << " " << m->properties.lookup("tab");
 		ss << "\n";
 		iter++;
diff --git a/iod/src/MachineInstance.cpp b/iod/src/MachineInstance.cpp
index 26ca8d6..3caea55 100644
--- a/iod/src/MachineInstance.cpp
+++ b/iod/src/MachineInstance.cpp
@@ -2351,6 +2351,7 @@ Action *MachineInstance::findHandler(Message&m, Transmitter *from, bool response
 					}
 					// the CALL method waits for a response once the executed command is complete
 					// the response will be sent after the transition to the next state is done
+#if 0
 					if (response_required && from) {
 						DBG_M_MESSAGING << _name << " command " << t.trigger.getText() << " completion requires response\n";
 						std::string response = _name + "." + t.trigger.getText() + "_done";
@@ -2358,6 +2359,17 @@ Action *MachineInstance::findHandler(Message&m, Transmitter *from, bool response
 						ExecuteMessageAction *ema = new ExecuteMessageAction(this, emat);
 						this->push(ema);
 					}
+#else
+					if (response_required && from) {
+						MachineInstance *from_mi = dynamic_cast<MachineInstance*>(from);
+						assert(from_mi);
+						DBG_M_MESSAGING << _name << " command " << t.trigger.getText() << " completion requires response\n";
+						std::string response = _name + "." + t.trigger.getText() + "_done";
+						ExecuteMessageActionTemplate emat(strdup(response.c_str()), "SELF");
+						ExecuteMessageAction *ema = new ExecuteMessageAction(from_mi, emat);
+						from_mi->push(ema);
+					}
+#endif
 					if (!found) {
 						DBG_M_STATECHANGES << "no stable state condition test for " << t.dest.getName() << " pushing state change\n";
 						MoveStateActionTemplate msat("SELF", t.dest.getName());
diff --git a/iod/src/iosh.cpp b/iod/src/iosh.cpp
index 708a674..67ec393 100644
--- a/iod/src/iosh.cpp
+++ b/iod/src/iosh.cpp
@@ -139,7 +139,7 @@ extern FILE *yyin;
 bool cmdline_done = false;
 
 void usage(const char *name) {
-	std::cout << name << " [-h host] [-p port]\n";
+	std::cout << name << " [q] [-h host] [-p port]\n";
 }
 
 std::list<char *>machine_names;
diff --git a/tests/trigger.lpc b/tests/trigger.lpc
index aac1fd0..ab04a88 100644
--- a/tests/trigger.lpc
+++ b/tests/trigger.lpc
@@ -1,4 +1,41 @@
-#TBD
+/*
+Test triggers
+
+*/
 FlipFlop MACHINE {
+	OPTION counter 0;
+	on STATE;
+	off INITIAL;
+	TRANSITION off TO on ON next;
+	TRANSITION on TO off ON next;
+
+	ENTER on { WAIT 990; SEND next TO SELF; }
+	ENTER off { WAIT 990; SEND next TO SELF; }
+	COMMAND count { counter := counter+1; }
+	COMMAND reset { counter := 0; }
+}
+ff FlipFlop;
 
+Timer MACHINE flipflop {
+	OPTION a 0;
+	idle INITIAL;
+	COMMAND reset { CALL reset ON flipflop; a := 0; }
+	COMMAND clear { a := 0; }
+	COMMAND inc{ CALL count ON flipflop; a := a + 1; }
 }
+timer Timer ff;
+
+Panel MACHINE flipflop, t {
+
+	COMMAND go { 
+		WAITFOR flipflop IS off;
+		CALL count ON flipflop;
+		CALL inc ON t;
+		WAITFOR flipflop IS on;
+		CALL count ON flipflop;
+		CALL inc ON t;
+	}
+}
+panel Panel ff, timer;
+
+#Test MACHINE { tolerance RANGECHECK; } test Test;
