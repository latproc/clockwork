Value &FindValue::operator()(MachineInstance *scope) {
	if (property_val == 0)
		property_val = scope->getValue(property_name.c_str());
	machine_list = scope->lookup(machine_list_name);
	if (!machine_list) {
		char buf[400];
		snprintf(buf, 400, "%s: no machine %s for index search %s",
						 scope->getName().c_str(), machine_list_name.c_str(), property_name.c_str());
		MessageLog::instance()->add(buf);
		last_result = 0;
		return last_result;
	}

	last_process_time = currentTime();
	if (machine_list->parameters.size() == 0) {
		last_result = -1;
		return last_result;
	}

	std::string prop_val;
	if (property_val != SymbolTable::Null) {
		prop_val = property_val.asString();
		int result = -1;
		// find or create the index to be used for the ITEM reference
		bool keep_item = false;
		bool add_item = true;
		unsigned int idx = 0;
		while (idx < machine_list->locals.size()) {
			if (machine_list->locals[idx].val.asString() == "ITEM") {
				keep_item = true;
				add_item = false;
				break;
			}
			++idx;
		}

		for (unsigned int i=0; i<machine_list->parameters.size(); ++i) {
			Value a(machine_list->parameters.at(i).val);
			MachineInstance *mi = machine_list->parameters.at(i).machine;
			if (!mi) mi = scope->lookup(machine_list->parameters[i]);
			if (!mi->parameters[i].machine) continue;

			// assign ITEM for the test
			machine_list->locals[idx] = a;
			machine_list->locals[idx].machine = mi;
			machine_list->locals[idx].val.cached_machine = mi;

			machine_list->locals[idx].val = Value("ITEM");
			machine_list->locals[idx].real_name = a.sValue;

			if (condition.predicate) {
				//std::cout << "flushing predicate cache\n";
				condition.predicate->flushCache();
				machine_list->localised_names["ITEM"] = mi;
			}

			if ( (!condition.predicate || condition(owner)) ){
				const Value &val = mi->getValue(prop_val);
			}

			if (val == property_val) {result = i; break; }
		}
		last_result = result;
	}
	else last_result = -1;
	return last_result;
}
