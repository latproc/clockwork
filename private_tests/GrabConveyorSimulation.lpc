# Grab machine hardware simulation 

SIMDUMMYCONVEYOR MACHINE { OPTION length 2000; OPTION scale 10; stopped INITIAL; is_forward FLAG; is_reverse FLAG; }

SIMENCODER MACHINE anain {
    OPTION new_value 0, position 0, last 0, start_pos 1000000;
    OPTION max 2000000000;
    OPTION PERSISTENT true;
    OPTION hidden "max,new_value,last";

    updating WHEN last != new_value; 
    ENTER updating {
        IF (new_value > max) { new_value := -max; };
        IF (new_value < -max) { new_value := max; };
        position := new_value;
        anain.VALUE := position; last := position; 
        SET SELF TO idle;
    }
    ENTER INIT { new_value := start_pos; }
    idle DEFAULT;
}

# conveyors have a length in counter pulses as well as a physical dimension
# the scaling factor between these two amount is automatically calculated
# for use in visualisation programs

SIMCONVEYOR MACHINE motor {
    OPTION length 3000; # counter pulses
    OPTION length_mm 1500; # millimetres
    OPTION scale 0;         # converts length in pulses to length in mm
    OPTION start 0;
    OPTION hidden "start";
    
    is_forward FLAG(tab:SimulateBales);
    is_reverse FLAG(tab:SimulateBales);
    
    moving WHEN motor IS turning;
    stationary DEFAULT;
    ENTER INIT { scale := length_mm * 1000 / length; }
}

SIMANALOGUEOUTPUT MACHINE {
    OPTION VALUE 16383;
    OPTION last 0;
    OPTION type AnalogueOutput;
    OPTION hidden "last";
    changed WHEN SELF IS changing;  ENTER changed { } # generate an event when the value changes
    changing WHEN last != VALUE;    ENTER changing { last := VALUE;  } # generate an event when the value changes
    idle DEFAULT;
}

SIMANALOGUEINPUT MACHINE {
    OPTION type AnalogueInput;
    OPTION VALUE 0;
    OPTION position 0;
}

# this fixed speed motor is controlled by two solenoids but it updates
# power values as if its an analogue conveyor so that it can drive
# an encoder

SIMFIXEDSPEEDMOTOR MACHINE fwd_sol, back_sol {
    OPTION VALUE 0; # motor drive value 0 .. 32767. Stationary is 16383
    OPTION Kspeed 33; # a scalar to convert value to speed in mm/sec
    OPTION scale 1000;
    OPTION zero 500; # the amount to move from centre before motion occurs
    OPTION max_value 32767;
    OPTION fixed_power 4000;
    OPTION hidden "scale";

    turning WHEN fwd_sol IS on OR back_sol IS on;
    stopped DEFAULT;

    RECEIVE fwd_sol.on_enter {  VALUE := max_value / 2 + fixed_power; }
    RECEIVE fwd_sol.off_enter {  VALUE := max_value / 2; }
    RECEIVE back_sol.on_enter { VALUE := max_value / 2 - fixed_power; }
    RECEIVE back_sol.off_enter { VALUE := max_value / 2; }
}

SIMOTOR MACHINE power_input {
    OPTION VALUE 16383; # motor drive power 0 .. 32767. Stationary is 16383
    OPTION Kspeed 333; # a scalar to convert power to speed in mm/sec
    OPTION scale 1000;
    OPTION zero 3000; # the amount to move from centre before motion occurs
    OPTION max_value 32767;
    OPTION hidden "scale";
    
    # at power of 15000 (12000 after taking the zero point into account) 
    # the conveyor moves at 3000mm/sec
    # therefore Kspeed = 1 / 12 * 4  = 0.333. 
    # since we have no floating point, use 333 / 1000

    turning WHEN VALUE <= max_value/2-zero OR VALUE >= max_value/2+zero;
    stopped DEFAULT;
    
    #TBD. this RECEIVE works for analogue inputs but not for property changes.
    RECEIVE power_input.changed_enter {
        VALUE := power_input.VALUE;
    }
    
    COMMAND stop { VALUE := max_value/2; direction := 0; }
    COMMAND forward { IF (SELF IS stopped) { VALUE := max_value/2+zero; } }
    COMMAND backward { IF (SELF IS stopped) { VALUE := max_value/2-zero;} }
    COMMAND faster { VALUE := VALUE + 100 }
    COMMAND slower { VALUE := VALUE - 100 }
}

# the carriage monitor accumulates movement of the carriage since the last
# time it stopped. The following integrator sits in a forward
# or backward state for a time and recalculates position when it leaves.

SIMANALOGUECARRIAGE MACHINE {
    OPTION length 32000; # length in encoder pulses
    OPTION length_mm 1000; # 1metre
    OPTION scale 125; # mm/tick *1000
    OPTION start 0;
    OPTION position 0;
    OPTION hidden "start";
    OPTION PERSISTENT "true";
    
    ENTER INIT { scale := length_mm * 1000 / length;}
}

# a carriage can move from 0..length. 

SIMCARRIAGEMONITOR MACHINE carriage, motor, encoder {
    OPTION count 0;
    OPTION last 0;
    OPTION last_power 0; # the last recorded motor power
    OPTION time_step 5;
    OPTION hidden "last,time_step";
    
    # the accumulating state is used to trigger a position calculation at 
    # regular intervals
    accumulating WHEN (SELF IS forward OR SELF IS backward) AND TIMER>=time_step;
    
    # we only care to track position when the conveyor is actually
    # carrying something
    
    forward WHEN carriage.position < carriage.length && motor.VALUE > motor.max_value / 2 + 2;
    backward WHEN carriage.position > 0 &&  motor.VALUE < motor.max_value / 2 - 2;
    blocked_forward WHEN carriage.position >= carriage.length;
    blocked_reverse WHEN carriage.position <= 0;
    zero DEFAULT;
    
    ENTER blocked_forward { carriage.position := carriage.length; encoder.new_value := carriage.position }
    ENTER blocked_reverse { carriage.position := 0; encoder.new_value := carriage.position }
    ENTER zero{
        last := count; count := 0; last_power := 0; velocity := 0;
    }
    
    # we use the average power over the sampled interval, subtract the zero point for the motor and
    # scale the appropriately to conver the power level to a speed in mm/sec
    ENTER forward { last_power := motor.VALUE - motor.max_value/2 - motor.zero }
    LEAVE forward {
        CALL calc_velocity ON SELF;
        CALL calc_distance ON SELF;
    }
    ENTER backward { last_power := motor.VALUE - motor.max_value/2 + motor.zero }
    LEAVE backward { 
        CALL calc_velocity ON SELF;
        CALL calc_distance ON SELF;
    }
    RECEIVE calc_velocity {
        current := motor.VALUE - motor.max_value/2;
        IF (current > motor.zero) { current := current - motor.zero }
        ELSE {
            IF (current <= motor.zero && current >= -motor.zero) {
                current := 0;
            } ELSE { IF (current < -motor.zero) { current := current + motor.zero } }
        };
        velocity := (last_power + current) / 2 * motor.Kspeed / motor.scale;
    }
    RECEIVE calc_distance {
        count := velocity * TIMER / 1000;
        encoder.new_value := encoder.new_value + count;
        carriage.position := carriage.position + count;
    }
}

SIMTIPPERBALE MACHINE {
    OPTION last 0, enc_pos 0;
    OPTION position 0;
    OPTION length 1200; # length in mm
    OPTION length_ticks 2400;   # length in counter pulses on the current conveyor. 
    
    active FLAG(tab:SimulateBales, type:Output);
    missing WHEN active IS off;
    idle DEFAULT;

    COMMAND load WITHIN missing {
        SET active TO on;
        position := 0;
    }
    
    COMMAND unload {
        SET active TO off;
    }
}

SIMBALE MACHINE prev_conveyor, prev_bale, encoder, conveyor, next_conveyor, next_bale  {
    OPTION last 0, enc_pos 0;
    OPTION position 0;
    OPTION length 1200; # length in mm
    OPTION length_ticks 2400;   # length in counter pulses on the current conveyor. 
                                # this is fixed when the bale is loaded
    OPTION new_pos 0;
    OPTION overrun 0, rev_overrun 0;
    OPTION hidden "last,enc_pos,new_pos,overrun,rev_overrun";
    
    active FLAG(tab:SimulateBales, type:Output);
    
    missing WHEN active IS off;
    fixing_length WHEN length_ticks != length *1000 / conveyor.scale;
    ENTER fixing_length { length_ticks := length *1000 / conveyor.scale }
    
    # When the encoder wraps around it will jump a large amount and the difference between
    # last and current value will be the opposite to normal.
    updating_wraparound_forward WHEN enc_pos > encoder.position + encoder.max/2;
    updating_wraparound_reverse WHEN enc_pos < encoder.position - encoder.max/2;
    
    transfer_forward WHEN enc_pos < encoder.position AND position >= conveyor.length AND next_conveyor.is_forward IS on AND next_bale.active IS off;
    transfer_reverse WHEN enc_pos > encoder.position AND position <= 0 AND prev_conveyor.is_reverse IS on AND prev_bale.active IS off;
    #removing_bale WHEN (SELF IS blocked_forward  && overrun != 0 || SELF IS blocked_reverse && rev_overrun != 0);
    blocked_forward WHEN enc_pos < encoder.position
        AND (position >= conveyor.length + overrun *1000 / conveyor.scale
                OR next_bale.active IS on AND position >= next_bale.position + conveyor.length - next_bale.length_ticks/2),
        EXECUTE remove WHEN overrun != 0;
    blocked_reverse WHEN enc_pos > encoder.position 
        AND (position <= -rev_overrun  *1000 / conveyor.scale
                OR prev_bale.active IS on AND position <= prev_bale.position - prev_conveyor.length + prev_bale.length_ticks/2),
        EXECUTE remove WHEN rev_overrun != 0;
   
    updating_forward WHEN enc_pos < encoder.position;
    updating_backward WHEN enc_pos > encoder.position;
    idle DEFAULT;
    
    ENTER INIT {  }
    
    ENTER updating_wraparound_forward {
        enc_pos := enc_pos - encoder.max;
        SET SELF TO idle; # force polling
    }
    
    ENTER updating_wraparound_reverse {
        enc_pos := enc_pos + encoder.max;
        SET SELF TO idle; # force polling
    }
    
    ENTER transfer_forward {
        LOG "Transfer forward";
        SET next_bale.active TO on;
        next_bale.position := position - conveyor.length;
        next_bale.new_pos := next_bale.position;
        next_bale.enc_pos := next_bale.encoder.position;
        CALL unload ON SELF;
    }
    
    ENTER transfer_reverse {
        LOG "Transfer reverse";
        SET prev_bale.active TO on;
        prev_bale.position := prev_conveyor.length + position; # (note position may have been slightly negative)
        prev_bale.new_pos := prev_bale.position;
        prev_bale.enc_pos := prev_bale.encoder.position;
       SET active TO off;
    }
    
    RECEIVE remove {
        SET active TO off;
    }
    
    ENTER blocked_forward {
        last := enc_pos;
        enc_pos := encoder.position;
        #position := conveyor.length;
        new_pos := position;
        SET SELF TO idle; # force polling
    }
    ENTER blocked_reverse {
        last := enc_pos;
        enc_pos := encoder.position;
        #position := 0;
        new_pos := position;
        SET SELF TO idle; # force polling
    }
   
    ENTER updating_forward {
        last := enc_pos;
        enc_pos := encoder.position;
        new_pos := new_pos + enc_pos - last;
        IF (new_pos > conveyor.length + overrun *1000 / conveyor.scale) { position := conveyor.length + overrun *1000 / conveyor.scale; } ELSE { position := new_pos };
        SET SELF TO idle; # force polling
    }
    ENTER updating_backward {
        last := enc_pos;
        enc_pos := encoder.position;
        new_pos := new_pos + enc_pos - last;
        IF (new_pos < -rev_overrun *1000 / conveyor.scale) { position := -rev_overrun *1000 / conveyor.scale; } ELSE { position := new_pos };
        SET SELF TO idle; # force polling
    }
    COMMAND load WITHIN missing {
        SET active TO on;
        length_ticks := length *1000 / conveyor.scale; # prepare the bale length for movement calculations
        enc_pos := encoder.position;
        last := enc_pos;
        position := conveyor.length/2;
        new_pos := position;
    }
    
    COMMAND unload {
        SET active TO off;
    }
}

# the conveyor monitor accumulates movement of the conveyor since the last
# time the conveyor stopped. The following integrator sits in a forward
# or backward state for a time and recalculates position when it leaves.

SIMCONVEYORMONITOR MACHINE conveyor, motor, encoder {
    OPTION count 0;
    OPTION last 0;
    OPTION last_power 0; # the last recorded motor power
    OPTION time_step 10;
    OPTION hidden "last,time_step";
    OPTION velocity 0;
    
    # the accumulating state is used to trigger a position calculation at 
    # regular intervals
    accumulating WHEN (SELF IS forward OR SELF IS backward) AND TIMER>=time_step;
    
    forward WHEN conveyor IS moving AND motor.VALUE > (motor.max_value / 2 + motor.zero);
    backward WHEN conveyor IS moving AND motor.VALUE < (motor.max_value / 2 - motor.zero);
    zero WHEN conveyor IS stationary;
    unknown DEFAULT;
    
    ENTER zero{
        last := count; count := 0; last_power := 0; 
        velocity := 0;
        SET conveyor.is_forward TO off;
        SET conveyor.is_reverse TO off;
    }
    
    # we use the average power over the sampled interval, subtract the zero point for the motor and
    # scale the appropriately to convert the power level to a speed in ticks / sec
    ENTER forward { 
        last_power := motor.VALUE - motor.max_value/2 - motor.zero;
        SET conveyor.is_reverse TO off; SET conveyor.is_forward TO on 
     }
    LEAVE forward {
        CALL calc_velocity ON SELF;
        CALL calc_distance ON SELF;
    }
    ENTER backward {
        last_power := motor.VALUE - motor.max_value/2 + motor.zero;
        SET conveyor.is_forward TO off; SET conveyor.is_reverse TO on 
    }
    LEAVE backward { 
        CALL calc_velocity ON SELF;
        CALL calc_distance ON SELF;
    }
    RECEIVE calc_velocity {
        current := motor.VALUE - motor.max_value/2;
        IF (current > motor.zero) { current := current - motor.zero }
        ELSE {
            IF (current <= motor.zero && current >= -motor.zero) {
                current := 0;
            } ELSE { IF (current < -motor.zero) { current := current + motor.zero } }
        };
        velocity := (last_power + current) / 2 * motor.Kspeed / motor.scale;
    }
    RECEIVE calc_distance {
        count := velocity * TIMER / 1000;
        encoder.new_value := encoder.new_value + count;
    }
}

SIMTIPPERBEAM MACHINE I_BalePresent {
    OPTION start_mm 150; # distance from the start of the conveyor in mm
    OPTION end_mm 150;
    OPTION start 300; # distance from the start of the conveyor in counter pulses
    OPTION end 300;
    
    on WHEN I_BalePresent IS on;
    off DEFAULT;
}

SIMBEAM MACHINE prev_conveyor, prev_bale, conveyor, bale, next_bale, output {
    OPTION start_mm 150; # distance from the start of the conveyor in mm
    OPTION end_mm 150;
    OPTION start 300; # distance from the start of the conveyor in counter pulses
    OPTION end 300;
    
    fixing WHEN start != start_mm * 1000 / conveyor.scale || end != end_mm * 1000 / conveyor.scale;
    on WHEN bale.active IS on AND bale.position > start - bale.length_ticks/2 AND bale.position < start + bale.length_ticks/2;
    on WHEN bale.active IS on AND bale.position > end - bale.length_ticks/2 AND bale.position < end + bale.length_ticks/2;
    on WHEN bale.active IS on AND bale.position > start + bale.length_ticks/2 AND bale.position < end - bale.length_ticks/2;
    on WHEN prev_bale.active IS on AND prev_bale.position - prev_conveyor.length + prev_bale.length_ticks/2 >= start;
    on WHEN next_bale.active IS on AND next_bale.position + conveyor.length - next_bale.length_ticks/2 <= end;
    off DEFAULT;
    
    ENTER on { SET output TO on }
    ENTER off { SET output TO off }
    
    ENTER fixing { 
        IF (end == -1 || end_mm == -1) { 
            end := conveyor.length; end_mm := conveyor.length * conveyor.scale / 1000; 
        }; 
        start := start_mm * 1000 / conveyor.scale;
        end := end_mm * 1000 / conveyor.scale;
    }
}

SIMTIPPER MACHINE I_BalePresent, M_Bale, M_Gate, M_FeederBale {
    OPTION BaleArrivalTime 2000;
    OPTION UnloadLength 400;
    OPTION position 0;
    
    make_bales FLAG(type:Output);
    
    unloaded WHEN SELF IS up AND position >= UnloadLength;
    ENTER unloaded { 
        SET M_Bale.active TO off;
        SEND load TO M_FeederBale;
        M_Bale.position := 0;
        position := 0;
    }

    feeding WHEN SELF IS up AND position < UnloadLength AND TIMER >= 20;
    ENTER feeding {
        position := position + 20;
        M_Bale.position := position;
    }
    
    fixing_beam_on WHEN I_BalePresent IS off && M_Bale.active IS on;
    fixing_beam_off WHEN I_BalePresent IS on && M_Bale.active IS off;
    ENTER fixing_beam_off { SET I_BalePresent TO off }
    ENTER fixing_beam_on { SET I_BalePresent TO on }

    make_bale WHEN SELF IS down AND make_bales IS on AND M_Bale.active IS off;
    ENTER make_bale { SET M_Bale.active TO on; SET I_BalePresent TO on; }
    
    down WHEN M_Gate.position == 0;
    up WHEN M_Gate.position == M_Gate.maxpos;
    moving DEFAULT;
    
#    ENTER up { SEND load TO M_FeederBale; }
    ENTER down { WAIT BaleArrivalTime; }
    ENTER INIT { 
        SET M_Bale.active TO on;
        make_bales.tab := tab;
        SET make_bales TO on;
    }
}

/*
SIMBALEMONITOR MACHINE reject_conveyor, feed_conveyor, cutter_conveyor, grab_conveyor,
                    SM_RejectBale, SM_FeederBale, SM_Cutterbale, SM_GrabBale
{
    updating_feed_bale_fwd WHEN SM_FeederBale.active IS on && SM_FeederBale.position < SM_FeederBale.new_pos;
    updating_feed_bale_rev WHEN SM_FeederBale.active IS on && SM_FeederBale.position > SM_FeederBale.new_pos;
    idle DEFAULT;
    
    ENTER updating_feed_bale_fwd {
        # stop the bale moving when it's at the end of the conveyor
        IF ( SM_FeederBale.new_pos >feed_conveyor.length) {
            SM_FeederBale.position := feed_conveyor.length; 
            SM_FeederBale.new_pos := feed_conveyor.length;
            SET SM_FeederBale.stuck TO on;
        } 
        ELSE {
            SM_FeederBale.position := SM_FeederBale.new_pos; 
             SM_FeederBale.new_pos := feed_conveyor.length;
           SET SM_FeederBale.stuck TO off;
        };
        SET self TO idle;
    }
    ENTER updating_feed_bale_rev {
        IF ( SM_FeederBale.new_pos < 0) {
            SM_FeederBale.position := 0; 
            SM_FeederBale.new_pos := 0; 
            SET SM_FeederBale.stuck TO on;
        }
        ELSE {
            SM_FeederBale.position := SM_FeederBale.new_pos; 
            SM_FeederBale.new_pos := feed_conveyor.length;
            SET SM_FeederBale.stuck TO off;
        };
        SET self TO idle;
    }
}
*/

# Visualisation

SIMCARRIAGEVISUALISATION MACHINE carriage, clamp, bale {
	OPTION tab "Vis3D";
	OPTION model "carriage";
	OPTION x_pos 0, y_pos 0, z_pos 0;
	OPTION x_offset 0, y_offset 750, z_offset 150;
	OPTION active false;
	OPTION scale 100;
	
	fixing WHEN SELF IS idle AND TIMER > 20 && z_pos != -carriage.position * carriage.scale / 1000 * scale / 100;    
	idle DEFAULT;
	ENTER fixing { SET SELF TO idle; z_pos := -carriage.position * carriage.scale / 1000 * scale / 100 }
	ENTER INIT { z_pos := -carriage.position * carriage.scale / 1000; }
}

SIMCLAMPVISUALISATION MACHINE clamp {
	OPTION tab "Vis3D";
	OPTION model "carriage";
	OPTION x_pos 0, y_pos 0, z_pos 0;
	OPTION z_len 880, x_len 1200;
	OPTION x_offset 0, y_offset 650, z_offset 0;
	OPTION active false;
	OPTION scale 100;
	
	fixing WHEN SELF IS idle AND TIMER > 20 && y_pos != -clamp.position * scale / 100; 
	idle DEFAULT;
	ENTER fixing { 
	    y_pos := -clamp.position * scale / 100;
	    SET SELF TO idle; 
	}
	ENTER INIT { 
	    y_pos := -clamp.position * scale / 100;
	}
}

SIMCYLINDERVISUALISATION MACHINE visualisation, carriage,cylinder {
	OPTION tab "Vis3D";
	OPTION model "cylinder";
	OPTION x_pos 0, y_pos 0, z_pos 0, y_len 400;
	OPTION x_offset 0, y_offset 700, z_offset 150;
	OPTION active false;
	OPTION scale 1;

	fixing WHEN SELF IS idle AND TIMER > 20 AND
	    (y_pos != -cylinder.position*cylinder.scale - 25 || z_pos != -carriage.position * carriage.scale / 1000 * visualisation.scale/100);
		
	idle DEFAULT;
	ENTER fixing { 
	    y_pos := -cylinder.position*cylinder.scale - 25; 
	    z_pos := -carriage.position * carriage.scale / 1000 * visualisation.scale/100;
	    SET SELF TO idle;
	}

	ENTER INIT {
	    y_pos := -cylinder.position*cylinder.scale - 25; 
	    z_pos := -carriage.position * carriage.scale / 1000 * visualisation.scale/100;
	}
}

SIMGATEVISUALISATION MACHINE gate {
	OPTION tab "Vis3D";
	OPTION model "x-gate";
	OPTION x_pos 0, y_pos 0, z_pos 0, y_len 300, x_len 400;
	OPTION x_offset 0, y_offset 700, z_offset 150;
	OPTION active false;
	OPTION scale 100;

	fixing WHEN y_pos != -gate.position*2 AND TIMER > 100;
	idle DEFAULT;
	ENTER fixing { 
	    y_pos := -gate.position*2; 
		SET SELF TO idle;
	}

	ENTER INIT {
	    y_pos := -gate.position*2; 
	}
}

SIMTIPPERVISUALISATION MACHINE M_tipper {
	OPTION tab "Vis3D";
	OPTION model "z-conveyor";
	OPTION x_pos 0, y_pos 0, z_pos 0, x_len 0;
	OPTION x_offset 0, y_offset 0, z_offset 0;
	OPTION active false;

	idle DEFAULT;
}

SIMCONVEYORVISUALISATION MACHINE conveyor {
	OPTION tab "Vis3D";
	OPTION model "x-conveyor";
	OPTION x_pos 0, y_pos 0, z_pos 0, x_len 0;
	OPTION x_offset 0, y_offset 0, z_offset 0;
	OPTION active false;
	
	fixing WHEN x_len != conveyor.length * conveyor.scale / 1000 && TIMER > 100;

	waiting WHEN conveyor IS stationary;

	idle DEFAULT;
	ENTER fixing{ 
    	x_len := conveyor.length * conveyor.scale / 1000;
	}
}

SIMzDIRCONVEYORVISUALISATION MACHINE conveyor {
	OPTION tab "Vis3D";
	OPTION model "z-conveyor";
	OPTION x_pos 0, y_pos 0, z_pos 0, x_len 0, z_len 0;
	OPTION x_offset 0, y_offset 0, z_offset 0;
	OPTION active false;
	
	fixing WHEN z_len != conveyor.length * conveyor.scale / 1000 && TIMER > 100;

	waiting WHEN conveyor IS stationary;

	idle DEFAULT;
	ENTER fixing{ 
    	z_len := conveyor.length * conveyor.scale / 1000;
	}
}

SIMBALEVISUALISATION MACHINE conveyor, bale{
	OPTION tab "Vis3D";
	OPTION model "bale";
	OPTION x_pos 0, y_pos 300, z_pos 0;
	OPTION x_offset 0, y_offset 0, z_offset 0;
	OPTION active false;

	makeActive WHEN active == "false" &&bale.active IS on;
	makeInactive WHEN active == "true" && bale.active IS off;

	updating WHEN x_pos != bale.position && conveyor IS stationary && SELF IS idle && TIMER > 200;
	updating WHEN x_pos != bale.position && conveyor IS NOT stationary && SELF IS idle && TIMER > 40;
	idle DEFAULT;
	ENTER makeActive {  x_pos := bale.position * conveyor.scale / 1000; active := "true" }
	ENTER makeInactive { active := "false" }
	ENTER updating { x_pos := bale.position * conveyor.scale / 1000 ; SET SELF TO idle }
}

SIMTIPPERBALEVISUALISATION MACHINE tipper, bale {
	OPTION tab "Vis3D";
	OPTION model "bale";
	OPTION x_pos 0, y_pos 600, z_pos 0;
	OPTION x_offset 0, y_offset 0, z_offset 0;
	OPTION active false;

	makeActive WHEN active == "false" &&bale.active IS on;
	makeInactive WHEN active == "true" && bale.active IS off;
	updating WHEN z_pos != -tipper.position && tipper IS down && SELF IS idle && TIMER > 200;
	updating WHEN z_pos != -tipper.position && tipper IS up && SELF IS idle && TIMER > 40;
	idle DEFAULT;
	ENTER makeActive {  z_pos := -bale.position; active := "true" }
	ENTER makeInactive { active := "false" }
	ENTER updating { z_pos := -bale.position; SET SELF TO idle }
}

SIMBEAMVISUALISATION MACHINE beam {
	OPTION tab "Vis3D";
	OPTION model "beam";
	OPTION x_pos 0, y_pos 400, z_pos 0;
	OPTION x_offset 0, y_offset 0, z_offset 0;
	OPTION active true;
	
  fixing WHEN x_pos != beam.start_mm && TIMER > 100;
  on WHEN beam IS on;
  off DEFAULT;
  ENTER fixing { 
     x_pos := beam.start_mm; 
  }
}

SIMPRESENCEBEAMVISUALISATION MACHINE beam {
	OPTION tab "Vis3D";
	OPTION model "presence";
	OPTION x_pos 0, y_pos 300, z_pos 0;
	OPTION x_offset 0, y_offset 0, z_offset 0;
	OPTION x_len 0;
	OPTION active true;
	
  fixing WHEN x_len != 50 + beam.end_mm - beam.start_mm && TIMER > 100;
  on WHEN beam IS on;
  off DEFAULT;
  ENTER fixing { 
    x_pos := beam.start_mm; 
    x_len := 50 + beam.end_mm - beam.start_mm; 
  }
}

