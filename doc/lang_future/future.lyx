#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 1cm
\topmargin 1cm
\rightmargin 1cm
\bottommargin 2cm
\headheight 1cm
\headsep 1cm
\footskip 1cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
The Future of the Clockwork Programming Language
\end_layout

\begin_layout Author
Martin Leadbeater
\end_layout

\begin_layout Abstract
Clockwork has been a work in progress since 2010, it was published in github
 around 2012.
 It has been able to be used to reliably control machinery since 2013 and
 has has demonstrated quite good code reuse and has been able to implement
 complex behaviours with small code components.
 This paper describes various language features that are being considered
 for future versions of Clockwork, based on our experiences with this type
 of programming.
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
Clockwork is not strictly typed but once a value is assigned to a variable
 a type is inferred and used to affect the type of the result.
 Program control within clockwork is done by defining actions that take
 effect on state changes; within those actions, calculations can be performed
 and other entities can be affected in various ways.
 
\end_layout

\begin_layout Subsection
Types
\end_layout

\begin_layout Itemize
Integers
\end_layout

\begin_layout Itemize
Strings
\end_layout

\begin_layout Itemize
Floating point calculations
\end_layout

\begin_layout Itemize
Binary values
\end_layout

\begin_layout Itemize
Sets and relationships
\end_layout

\begin_layout Itemize
Lists
\end_layout

\begin_layout Itemize
References
\end_layout

\begin_layout Itemize
Type conversions (x AS type)
\end_layout

\begin_layout Itemize
Key-value access to redis has been implemented via a plugin
\end_layout

\begin_layout Subsubsection
Not implemented
\end_layout

\begin_layout Itemize
Streams (also generators)
\end_layout

\begin_layout Itemize
Replace the current symbol table and Value system with a more efficient
 and robust implementation
\end_layout

\begin_layout Itemize
Type extensions (except for channels)
\end_layout

\begin_layout Itemize
Records/Property Sets
\end_layout

\begin_layout Itemize
Database/Key-Value
\end_layout

\begin_layout Itemize
Queue
\end_layout

\begin_layout Subsection
Data
\end_layout

\begin_layout Itemize
Sharing properties or data
\end_layout

\begin_layout Itemize
Events with data
\end_layout

\begin_layout Itemize
Copying properties en mass via variants of COPY PROPERTIES
\end_layout

\begin_layout Subsection
Features
\end_layout

\begin_layout Standard
Not all of these are implemented directly, some of these can be implemented
 in library code or plugins and do not need to be language features per-se.
\end_layout

\begin_layout Itemize
Substates (implemented via nesting of machines)
\end_layout

\begin_layout Itemize
Exceptions [prerelease] (THROW, CATCH), no global CATCH at present
\end_layout

\begin_layout Itemize
Conditions
\end_layout

\begin_layout Itemize
Processing priorities - low priority/slow scan inputs
\end_layout

\begin_layout Itemize
Functions (passing parameters and getting a return result)
\end_layout

\begin_layout Itemize
External function calls
\end_layout

\begin_layout Itemize
Dynamic allocation (ie creating and destroying data items)
\end_layout

\begin_layout Itemize
Dynamic configuration (creating and destroying machines)
\end_layout

\begin_layout Itemize
Modular/dynamic components
\end_layout

\begin_layout Itemize
Support of parallel execution (calculation of stable states and execution
 of actions)
\end_layout

\begin_layout Itemize
Controlling safe access to data - stable and changing property states, dynamic
 data privacy
\end_layout

\begin_layout Itemize
Sequences and Cycles - shortcuts for transition tables? Transitions are
 limited to be within a list or a cycle of states.
\end_layout

\begin_layout Itemize
Executing a subexpression on the default state
\end_layout

\begin_layout Itemize
Persistence (via persistd)
\end_layout

\begin_layout Itemize
Property type and state enforcement via STRICT
\end_layout

\begin_layout Itemize
namespace scopes
\end_layout

\begin_layout Itemize
Macros
\end_layout

\begin_layout Itemize
State validation during handlers
\end_layout

\begin_layout Itemize
Syncronisation of read via shared clock
\end_layout

\begin_layout Subsubsection
Potential other features
\end_layout

\begin_layout Itemize
Method extensions
\end_layout

\begin_layout Itemize
WAITing for a machine to enter a state currently only checks that the state
 name has changed.
 It should also wait for the enter_function to have been processed.
 A complex solution to this problems is discussed later; utilising CHANGING
 STATE operators but perhaps there is a simpler method also.
\end_layout

\begin_layout Subsection
Bugs
\end_layout

\begin_layout Itemize
Passing SELF to an internal object
\end_layout

\begin_layout Itemize
Stable states that use timers of other machines (retest)
\end_layout

\begin_layout Itemize
State changes during stable state evaluation (details?)
\end_layout

\begin_layout Subsection
Communication
\end_layout

\begin_layout Itemize
Communication between instances of clockwork drivers
\end_layout

\begin_layout Itemize
Global configuration (eg timer range in usec, msec, sec)
\end_layout

\begin_layout Itemize
Formal/scrict interfaces
\end_layout

\begin_layout Itemize
sending data with a message
\end_layout

\begin_layout Itemize
holding messages that arrive outside the state where they can be used
\end_layout

\begin_layout Itemize
limiting execution of commands apart from in certain states
\end_layout

\begin_layout Subsection
Modules
\end_layout

\begin_layout Itemize
PID controls - ramps, constant speed
\end_layout

\begin_layout Itemize
Counter inputs
\end_layout

\begin_layout Itemize
Frequency inputs (calculated or read from advanced devices)
\end_layout

\begin_layout Itemize
Low level module initialisation
\end_layout

\begin_layout Itemize
Bus change events
\end_layout

\begin_layout Itemize
CAN objects for paramaterisation
\end_layout

\begin_layout Subsection
Time
\end_layout

\begin_layout Itemize
Delayed messaging (sending messages after a delay and cancelling..)
\end_layout

\begin_layout Itemize
Wall time (long period timers)
\end_layout

\begin_layout Itemize
Polling - repeatedly executing a statement
\end_layout

\begin_layout Itemize
Retriggering EXECUTE / TAG actions
\end_layout

\begin_layout Subsection
Macros
\end_layout

\begin_layout Standard
Macros provide a way to restructure the source into a form that improved
 readability.
 The macro facilty is simply a string replacement with the ability to substitute
 variables within the string as it is inserted.
\end_layout

\begin_layout Subsection
Dynamic instantiation
\end_layout

\begin_layout Standard
Since machines are defined statically there is no way to create a new machine
 or destroy one that is not needed.
 The language uses properties to store values and although machines can
 be named, there is no way to make a property that refers to a machine although
 it is possible to have a reference to a machine.
 It is not even possible to save the state of a machine and restore that
 state later.
 [this is changing (see LIST), TBD]
\end_layout

\begin_layout Section
Feature discussion
\end_layout

\begin_layout Standard
Clockwork is currently based around the notion of machines, states and propertie
s.
 Machines cannot carry data per-se but since the property system provides
 for simple key-value objects, the effect can be simulated at a basic level.
 Machines also need the notion of a working-set of data that is being processed
 or held.
 Traditionally data is grouped into 'structure's or 'object's and these
 terms and their common usage seems fine.
 More generally, a 'working set', if we chose to use the term, would refer
 to a collection of various values, structures and objects.
\end_layout

\begin_layout Subsection
Value system
\end_layout

\begin_layout Standard
The way property values are stored in machines desparately needs an overhaul;
 the current system is build on a C type structure and uses runtime type
 comparions.
 A new version will use C++ virtual methods that bind functions at compile
 time.
\end_layout

\begin_layout Subsubsection
Floating point values
\end_layout

\begin_layout Standard
Within clockwork, floating point values are used as in the following examples:
\end_layout

\begin_layout LyX-Code
OPTION x 1.0;
\end_layout

\begin_layout LyX-Code
OPTION y 1.;
\end_layout

\begin_layout LyX-Code
OPTION z 1.3E3;
\end_layout

\begin_layout Standard
Usage
\end_layout

\begin_layout LyX-Code
OPTION a 1;
\end_layout

\begin_layout LyX-Code
OPTION x 1.3;
\end_layout

\begin_layout LyX-Code
a := a + x; /* a converted to float with value 2.3 */
\end_layout

\begin_layout LyX-Code
a := INT(a+x); /* INT is an alias for INTEGER */
\end_layout

\begin_layout LyX-Code
a := a + x AS INTEGER;
\end_layout

\begin_layout LyX-Code
a := (a + x) AS INTEGER;
\end_layout

\begin_layout Standard
Equality tests for floating point values can given a tolerance:
\end_layout

\begin_layout Standard
x == y WITHIN 0.001;
\end_layout

\begin_layout Subsubsection
Engineering values
\end_layout

\begin_layout Standard
We could explore the ability to refer to values with units, to help readability
 and clarify the calculations being performed.
 The IN keyword can be used to express values in other units.
\end_layout

\begin_layout LyX-Code
x := 1 hr;
\end_layout

\begin_layout LyX-Code
y := x IN min;
\end_layout

\begin_layout Standard
There are a small set of predefined endineering values but this set can
 be extended within user configurations.
 TBD work on this syntax
\end_layout

\begin_layout LyX-Code
hr EXPRESSED IN min USES { min / 60 }
\end_layout

\begin_layout LyX-Code
min EXPRESSED IN hr USES { hr * 60 }
\end_layout

\begin_layout Standard
Probably the term 'EXPRESSED' could be omitted here.
\end_layout

\begin_layout Subsubsection
Type translation
\end_layout

\begin_layout Standard
Values are typed internally and can be forcibly converted from one type
 to another via the AS operator:
\end_layout

\begin_layout LyX-Code
a := b AS INTEGER;
\end_layout

\begin_layout LyX-Code
b := a AS FLOAT
\end_layout

\begin_layout Standard
Numeric values can be combined in expressions without specific type casting
 and the rules for determining resultant types are:
\end_layout

\begin_layout Itemize
string expressions cause numeric values to be converted to strings in the
 result
\end_layout

\begin_layout Itemize
when a floating point value is used in an subexpression, the subexpression
 type is converted to floating point
\end_layout

\begin_layout Itemize
floating point values will be displayed in fixed-point notation from clockwork
 (hard-coded at 3 decimal places at present
\end_layout

\begin_layout Subsection
Sets and relationships
\end_layout

\begin_layout Standard
We need to decide whether bits that are allocated to symbols should be allocated
 in least-significant or most-significant order.
 Perhaps a mapping function should be used (like a C union), with this in
 mind, defining three symbols, x,y and z to a block of bits would map bit
 2 to x, bit 1 to y and bit 0 (least significant) to z.
 This gives a nice mapping for those who visualise the bits in a block and
 want to map the symbols over the block.
\end_layout

\begin_layout LyX-Code
cutter1 Cutter;
\end_layout

\begin_layout LyX-Code
cutter2 Cutter;
\end_layout

\begin_layout LyX-Code
B BITSET [a,b,c,d]; # defines symbols a..d for bits 0..3
\end_layout

\begin_layout LyX-Code
C BITSET [r:8,g:8,b:8]; # defines symbols r,g and b for bits 0..23 of C
\end_layout

\begin_layout LyX-Code
INCLUDE a,d IN B
\end_layout

\begin_layout LyX-Code
x := B AS INTEGER;
\end_layout

\begin_layout LyX-Code
cutters SET[cutter1, cutter2];
\end_layout

\begin_layout LyX-Code
s INCLUDES? [a,b,c];
\end_layout

\begin_layout LyX-Code
SELECT state_name/value FROM set_name;
\end_layout

\begin_layout Standard
Sets could be implemented as a machine where each combination of members
 is a distinct state there doesn't seem to be much value in this.
 It may be useful to use three states: empty, nonempty and full.
\end_layout

\begin_layout Standard
Statements involving sets may be classified by whether they refer to the
 set itself, for example `INCLUDE 3 IN s', or the members.
 
\end_layout

\begin_layout Standard
Sets can be used in expressions in the following ways
\end_layout

\begin_layout Itemize
ANY IN set_name ARE | IS state_name # returns true if any of the items in
 the set are in the state given
\end_layout

\begin_layout Itemize
ANY PROPERTY property IN set_name ARE | IS value
\end_layout

\begin_layout Itemize
ALL IN set_name ARE | IS state_name/value
\end_layout

\begin_layout Itemize
ALL PROPERTY property_name IN set_name ARE | IS state_name/value
\end_layout

\begin_layout Itemize
COUNT state_name FROM set_name # counts the number of items in the set that
 are in the named state
\end_layout

\begin_layout Itemize
COUNT WHERE expression FROM set_name # counts the number of items in the
 set where the expression returns true 
\end_layout

\begin_layout Itemize
BITSET FROM set_name state_name # returns a bitset that represents the an
 on/off value for the given state name.
 Further examples use variable values..
\end_layout

\begin_layout Itemize
COPY n FROM set_name # picks n elements at random from a set
\end_layout

\begin_layout Itemize
TAKE n FROM set_name # takes n elements at random from a set
\end_layout

\begin_layout Subsubsection
Special Sets
\end_layout

\begin_layout Description
ALL [MACHINES]
\end_layout

\begin_layout Description
ENABLED [MACHINES]
\end_layout

\begin_layout Description
CHANNELS a list of all channels
\end_layout

\begin_layout Subsubsection
Operators
\end_layout

\begin_layout Description
CLASS
\end_layout

\begin_layout Subsubsection
Enumeration
\end_layout

\begin_layout Standard
There should be a way to trigger events for each item in a set: 
\end_layout

\begin_layout LyX-Code
EACH item IN set DO command
\end_layout

\begin_layout Standard
at present, a message can be sent to all members of a set by sending the
 message to the set but there is no simple way to know when the message
 has been handled by all machines.
\end_layout

\begin_layout Subsubsection
Events
\end_layout

\begin_layout Standard
Sets should send messages on state change between empty, nonempty and full.
 It may be useful to send events as each item enters/leaves but at this
 point that seems excessive and of little value.
\end_layout

\begin_layout Subsubsection
Structs
\end_layout

\begin_layout Standard
Structs are a way to structure or group property names that can be used
 to initialise machines or used to change the value of several properties
 at the same time.
\end_layout

\begin_layout Standard
Initialising a machine will look something like:
\end_layout

\begin_layout LyX-Code

\size small
Sample MACHINE WITH (a:1, b:
\begin_inset Quotes erd
\end_inset

test
\begin_inset Quotes erd
\end_inset

) { ...
 }
\end_layout

\begin_layout Standard
or 
\end_layout

\begin_layout LyX-Code

\size small
my_properties STRUCT {
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
OPTION a 1;
\end_layout

\begin_layout LyX-Code

\size small
OPTION b 
\begin_inset Quotes eld
\end_inset

test
\begin_inset Quotes erd
\end_inset

;
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout LyX-Code

\size small
Sample MACHINE WITH my_properties { ...
 }
\end_layout

\begin_layout Standard
Property sets can be updated from a database:
\end_layout

\begin_layout LyX-Code

\size small
COLLECT record FROM data_source INTO my_properties ON ENDOFDATA done;
\end_layout

\begin_layout LyX-Code

\size small
UPDATE my_machine WITH my_properties [EXCLUDING name_list];
\end_layout

\begin_layout LyX-Code

\size small
UPDATE my_machine WITH [name_list FROM] my_properties
\end_layout

\begin_layout Standard
When a Property Set is being applied it is the changes are made to an invisible
 data structure linked to the property set.
 Once all of the invisible data values are updated the values are applied
 into the machine and a property_change event is triggered.
\end_layout

\begin_layout Standard
A normal property change that is executed while a property set is being
 update will be handled as normal.
 If that change updates a property that is changing within the Property
 Set the changed value will be lost on completion of the change.
 The effect is that the property assignments might occur out of order.
\end_layout

\begin_layout Standard
Property Set changes may be performed against shadowed data and the update
 will not occur until all properties are synchronised at both ends of the
 channel.
\end_layout

\begin_layout Standard
Partial updates from Property Sets should also be possible
\end_layout

\begin_layout LyX-Code
COPY PROPERTIES a,b,c FROM machine_a TO machine_b;
\end_layout

\begin_layout Standard
See also comments about structured data, below.
\end_layout

\begin_layout Subsubsection
Dynamic values
\end_layout

\begin_layout Standard
Some expressions include a calculation that needs to be reevaluated each
 time the expression is evaluated, these are calculations, for example of
 the size of a list, the class of a machine, the number of items on a list
 that are in a given state.
 These `dynamic values' are:
\end_layout

\begin_layout Itemize
ANY IN
\end_layout

\begin_layout Itemize
ALL IN
\end_layout

\begin_layout Itemize
COUNT ..
 FROM ..
\end_layout

\begin_layout Itemize
SIZE OF
\end_layout

\begin_layout Itemize
INCLUDES
\end_layout

\begin_layout Itemize
ITEM AT
\end_layout

\begin_layout Itemize
BITSET FROM
\end_layout

\begin_layout Itemize
ENABLED
\end_layout

\begin_layout Itemize
DISABLED
\end_layout

\begin_layout Itemize
EXISTS
\end_layout

\begin_layout Itemize
CLASS OF
\end_layout

\begin_layout Itemize
SUM OF list [ not implemented yet]
\end_layout

\begin_layout Itemize
VALUE OF symbol [when is this needed]
\end_layout

\begin_layout Itemize
INVALID statename
\end_layout

\begin_layout Subsubsection
Automatic properties
\end_layout

\begin_layout Standard
Properties can be defined to be equivalent to the result of a calculation
 by using the LET command:
\end_layout

\begin_layout LyX-Code
LET property_name BE expression;
\end_layout

\begin_layout Standard
When defind this way, the expression will be evaluated when necessary, for
 example when one of its members changes.
 The guarantee applies (at least initially) only for state calculations
 and upon entry to a command or state-change method.
 Automatic properties are private.
\end_layout

\begin_layout Subsubsection
Conditional Assignment
\end_layout

\begin_layout Standard
The conditional assignment operator provides a way to make an assignment
 based on evaluation of conditions.
 A synopsis is:
\end_layout

\begin_layout LyX-Code
property =: expression1 WHEN condition1 [, expression2 WHEN condition2]
 ...
 [ expressionN OTHERWISE]
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Standard
the first assignments is made based on the first condition to evaluate to
 true when evaluated in the order written.
 This is equivalent to:
\end_layout

\begin_layout LyX-Code
IF condition1 property := expression1
\end_layout

\begin_layout LyX-Code
ELSIF condition2 property := expression2
\end_layout

\begin_layout LyX-Code
...
\end_layout

\begin_layout LyX-Code
[ELSE property := expressionN]
\end_layout

\begin_layout Subsubsection
Invariants
\end_layout

\begin_layout Standard
Methods can contain declarations of invariant conditions.
 If an invariant is evaluated as false the program cannot continue to run
 and will enter its failsafe mode
\end_layout

\begin_layout Subsubsection
Strict
\end_layout

\begin_layout Standard
When applied to a machine, STRICT causes the machine to refuse to change
 the type of a property once set and causes a system exit if a machine is
 asked to transition to an unknown state.
 
\end_layout

\begin_layout Subsubsection
Failsafe Mode
\end_layout

\begin_layout Standard
A program may be configured with a failsafe mode that includes a set of
 states and properties that can be activated whenever the program detects
 a non-recoverable error.
 Failsafe mode can be activated by:
\end_layout

\begin_layout Itemize
throwing an exception that nothing catches,
\end_layout

\begin_layout Itemize
causing an invariant to evaluate to false
\end_layout

\begin_layout Itemize
executing a FAIL statement.
\end_layout

\begin_layout Standard
The syntax for this feature has not been decided yet.
\end_layout

\begin_layout Subsubsection
Data Sources
\end_layout

\begin_layout Standard
Data sources are objects that provide data, either on a polled or automatic
 basis.
\end_layout

\begin_layout LyX-Code
my_data DATASOURCE {
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout LyX-Code
COMMANDS { 
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout LyX-Code
CONNECT, # connect to the external source
\end_layout

\begin_layout LyX-Code
DISCONNECT, # disconnect from the external source
\end_layout

\begin_layout LyX-Code
NEXT # attempt to get a record from the external source and update linked
 properties
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
They can be linked to a property set:
\end_layout

\begin_layout LyX-Code
LINK my_data TO my_properties;
\end_layout

\begin_layout LyX-Code
LINK my_properties TO my_machine, ...;
\end_layout

\begin_layout Subsection
Functions
\end_layout

\begin_layout Standard
Actions are executed when a message is received by a machine.
 These actions may return a result that can be used in a property assignment.
\end_layout

\begin_layout Standard
Steps within a function are executed until a step cannot be resolved immediately
, for example, when a SET statement is used to set the state of another
 machine.
 The SET does not complete until the other machine has changed state.
 In the current implementation, the other machine may have only started
 to invoke its ENTER function (TBD).
\end_layout

\begin_layout Standard
Steps may be artifically stopped by using the YIELD statement and in the
 future functions may be interrupted because of the use of a regular I/O
 poll.
 
\end_layout

\begin_layout Standard
It should be assumed that there is no guarantee that non-blocking steps
 of a method are always executed at once but this happens to be a property
 of the current implementation.
\end_layout

\begin_layout Standard
A function may be invoked by a CALL statement in which case the calling
 machine blocks until the function is complete.
 On completion, a result property 'RESULT' will contain the result of the
 function.
 RESULT is actually a REFERENCE (see section 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:References"

\end_inset

) so it can return multiple properties and a reference to a machine.
 For example:
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
CALL method ON machine;
\end_layout

\begin_layout LyX-Code
property := RESULT.val;
\end_layout

\begin_layout LyX-Code
SEND go TO RESULT.ITEM;
\end_layout

\begin_layout Standard
TBD add details about parameters.
\end_layout

\begin_layout Subsection
References
\begin_inset CommandInset label
LatexCommand label
name "subsec:References"

\end_inset


\end_layout

\begin_layout Standard
The reference type REFERENCE is provided to provide a way to make a reference
 to another object.
 It has operations to assign and to clear the reference and has two states:
 EMPTY and ASSIGNED.
 Once an object is assigned to a reference, the object can be obtained using
 reference.ITEM.
 Referring to the ITEM on an empty reference produces undefined behaviour.
\end_layout

\begin_layout Standard
The implementation of a reference is similar to 
\end_layout

\begin_layout LyX-Code

\size small
REFERENCE MACHINE {
\end_layout

\begin_layout LyX-Code

\size small
    ITEM ANY_MACHINE;
\end_layout

\begin_layout LyX-Code

\size small
    ASSIGNED WHEN ITEM != NULL;
\end_layout

\begin_layout LyX-Code

\size small
    EMPTY DEFAULT;
\end_layout

\begin_layout LyX-Code

\size small
    
\end_layout

\begin_layout LyX-Code

\size small
    COMMAND clear { } # clear the current ITEM 
\end_layout

\begin_layout LyX-Code

\size small
    COMMAND assign WITH new_item {  } # clear the current item then set
 it to new_item
\end_layout

\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard
Calling clear on the reference will unassign the object that was previously
 assigned and calling assign will perform an assignment.
 
\end_layout

\begin_layout Standard
Note: Initially, the language does not provide a way to return an object
 from a function.
\end_layout

\begin_layout Subsubsection
Properties that refer to other properties
\end_layout

\begin_layout Standard
This feature is only partially implemented
\end_layout

\begin_layout LyX-Code

\size small
PropertyReferenceExample MACHINE {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
# The VALUE property is linked to the 'answer' property of 
\end_layout

\begin_layout LyX-Code

\size small
# the local machine 'calculator'
\end_layout

\begin_layout LyX-Code

\size small
OPTION VALUE REFER TO calculator.answer;
\end_layout

\begin_layout LyX-Code

\size small
LOCAL calculator;
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Subsection
Iterator
\end_layout

\begin_layout Standard
An ITERATOR is like a REFERENCE except that it is linked to an item within
 a list.
 Iterators provide additional methods, 'prev' and 'next'.
 When an ITERATOR points to a member of its list, it is 'ASSIGNED' if it
 is moved before the first value or after the last value, it is 'EMPTY'.
\end_layout

\begin_layout LyX-Code

\size small
iter ITERATOR list; # automatically assigns FIRST OF LIST to iter
\end_layout

\begin_layout LyX-Code

\size small
working WHEN iter IS ASSIGNED;
\end_layout

\begin_layout LyX-Code

\size small
idle DEFAULT;
\end_layout

\begin_layout LyX-Code

\size small
ENTER working { LOG iter.ITEM.NAME; SEND next TO iter; }
\end_layout

\begin_layout LyX-Code

\size small
ENTER idle { LOG 
\begin_inset Quotes eld
\end_inset

------
\begin_inset Quotes erd
\end_inset

; RESET iter; }
\end_layout

\begin_layout Standard
The FIND statement can be used to search a list for a match and return an
 iterator at the found position.
\end_layout

\begin_layout Standard
Similarly, the SEEK command can be used to obtain an iterator that points
 to a specific index within a list.
\end_layout

\begin_layout Standard
ITERATORs may be assigned to REFERENCEs so the following code is ok except
 that the reference has no ability to move through the list.
\end_layout

\begin_layout LyX-Code

\size small
ref REFERENCE;
\end_layout

\begin_layout LyX-Code

\size small
iter ITERATOR;
\end_layout

\begin_layout LyX-Code

\size small
a OBJECT(val:1); b OBJECT(val:3);
\end_layout

\begin_layout LyX-Code

\size small
list LIST a, b;
\end_layout

\begin_layout LyX-Code

\size small
COMMAND example {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
x := FIND ITEM.val == 3 IN list;
\end_layout

\begin_layout LyX-Code

\size small
ASSIGN x TO iter; IF iter ASSIGNED { SEND prev TO iter; }
\end_layout

\begin_layout LyX-Code

\size small
ASSIGN x TO ref; # ref still works as a REFERENCE 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Subsection
Streams
\end_layout

\begin_layout Standard
A Stream is an ordered collection of data that can be grouped into fixed
 size units (bits, bytes, chars etc); it has a current value and position.
 the position can be moved forward or backward and the value can be read
 and changed.
 Streams may have a beginning and end and has a state of closed, valid or
 invalid.
 In the closed and invalid state, the current value cannot be read; if the
 stream is moved past the end or before its beginning, it becomes invalid.
 A Reader is a special case of a Stream in which the data cannot be changed,
 similarly, a Writer is a Stream that can only be written to.
\end_layout

\begin_layout LyX-Code
s FILESTREAM 
\begin_inset Quotes eld
\end_inset

example.dat
\begin_inset Quotes erd
\end_inset

;
\end_layout

\begin_layout LyX-Code

\size small
r READER s(block_size:1); # read one char at a time
\end_layout

\begin_layout LyX-Code
demo Demo r;
\end_layout

\begin_layout LyX-Code
Demo MACHINE r {
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
done WHEN SELF IS done OR r IS invalid; # terminating condition
\end_layout

\begin_layout LyX-Code

\size small
start WHEN r IS closed;
\end_layout

\begin_layout LyX-Code

\size small
one WHEN r.curr == '1';
\end_layout

\begin_layout LyX-Code

\size small
zero WHEN r.curr == '0';
\end_layout

\begin_layout LyX-Code
other DEFAULT;
\end_layout

\begin_layout LyX-Code
ENTER done { SEND close TO r }
\end_layout

\begin_layout LyX-Code

\size small
ENTER start { SEND open TO r }
\end_layout

\begin_layout LyX-Code

\size small
ENTER one { LOG 
\begin_inset Quotes eld
\end_inset

1
\begin_inset Quotes erd
\end_inset

; SEND forward TO r }
\end_layout

\begin_layout LyX-Code

\size small
ENTER zero { LOG 
\begin_inset Quotes eld
\end_inset

0
\begin_inset Quotes erd
\end_inset

; SEND forward TO r }
\end_layout

\begin_layout LyX-Code
ENTER other { SEND forward TO r }
\end_layout

\begin_layout LyX-Code
COMMAND run WITHIN done { SET SELF TO start; }
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
FILESTREAM options
\end_layout

\begin_layout Itemize
mode: (read, write, readwrite, append)
\end_layout

\begin_layout Standard
READER options
\end_layout

\begin_layout Itemize
block_size: (positive integer)
\end_layout

\begin_layout Itemize
block_terminated: (character)
\end_layout

\begin_layout Subsection
Data
\end_layout

\begin_layout Standard
Machines currently have an unstructured set of properties as the only method
 of handling data.
 In the short term this won't change but we are starting to add some tools
 to help manupulate data.
 For example
\end_layout

\begin_layout LyX-Code

\size small
COPY PROPERTIES FROM machine1 TO machine2
\end_layout

\begin_layout LyX-Code

\size small
COPY PROPERTIES property_name,...
 FROM machine1 TO machine2
\end_layout

\begin_layout Standard
Note that this statement does not copy the reserved properties NAME and
 STATE, other pseudo-properties like TIMER or properties marked as LOCAL.
\end_layout

\begin_layout Standard
It is convenient to be able to save and restore the state of an entire list
 of objects.
 One mechanism to support this is the bit functions; a list of objects can
 be packed into a bitmap, represented in the language by a property value.
 For example, a LIST may contain a list of FLAG machines, each of which
 have a state of on or off.
 This list can be mapped to a an array of bits where each bit records the
 state of a machine.
 In theory, a list can be of arbitrary length and so can a BITMAP, in practice,
 we expect that many algorithms only need a small list and so such a list
 may be able to be packed into a single integer property value.
 BITSET values are packed structures that can pack lists with a limited
 number of items (currently 32) [and possibly with the advantage that the
 items of a bitset are still addressible].
\end_layout

\begin_layout Standard
Further, a BITSET can be generated from properties as well as states in
 either case, a notation is required that provides a way to describe the
 way that bitsets are packed.
 
\end_layout

\begin_layout Standard
The state of list entries can be converted to a bitset and back using statements
 like the following
\end_layout

\begin_layout LyX-Code

\size small
my_flags := BITSET FROM ENTRIES OF list WITH STATES off,on
\end_layout

\begin_layout LyX-Code

\size small
SET ENTRIES OF list FROM BITSET my_flags WITH STATES [on=1,off=0]
\end_layout

\begin_layout Standard
Equivalent forms exist that can map a set or properties rather than states
\end_layout

\begin_layout LyX-Code

\size small
val := BITSET FROM ENTRIES OF list WITH PROPERTY a;
\end_layout

\begin_layout LyX-Code

\size small
SET PROPERTIES OF ENTRIES OF list FROM BITSET val WITH PROPERTY [a:1];
\end_layout

\begin_layout Standard
Both the state and property forms of these statements can be abbreviated
 by removal of the 'ENTRIES OF' clauses:
\end_layout

\begin_layout LyX-Code

\size small
my_flags := BITSET FROM list WITH STATES off,on
\end_layout

\begin_layout LyX-Code

\size small
SET list FROM BITSET my_flags WITH STATES [on=1,off=0]
\end_layout

\begin_layout Standard
In both cases, the WITH STATES clauses can also be removed if the specification
 is using a list of flags or a list of integers:
\end_layout

\begin_layout LyX-Code

\size small
my_flags := BITSET FROM list;
\end_layout

\begin_layout LyX-Code

\size small
SET list FROM BITSET my_flags;
\end_layout

\begin_layout Subsubsection
Bit packing notation
\end_layout

\begin_layout Standard
The programmer can control how states or properties are mapped into a bitmap;
 a subset of states may be used and multiple bits per state or property
 may also be used.
 The notation is
\end_layout

\begin_layout LyX-Code

\size small
specification = specifier | '[' specifier [ ',' specifier ] ']'
\end_layout

\begin_layout LyX-Code

\size small
specifier = name [ '=' value ] [ ':' size ]
\end_layout

\begin_layout Standard
The size indicate sets the number of bits to be used for each value, if
 it is not given, the size will be the smallest number of bits needs to
 hold the largest value in the specification.
 The name is the name of the state or the name of the property, depending
 on the statement in which the specification is being used.
 The value is a non-negative integer (0,1,2,..) giving the bit pattern to
 be used to represent each state.
 Note that in this specification, there is currently no way to nominate
 whether a big-endian or little endian packing of the values.
\end_layout

\begin_layout Standard
For example, 
\end_layout

\begin_layout Description
on=1,off=0 indicates that state or property 'on' will be represented by
 one and state or property 'off' will be represented by zero.
 
\end_layout

\begin_layout Description
off,on has the same effect; since no value is given, it defaults to 0, 1
 etc and all states or properties not represented in the list map to zero
\end_layout

\begin_layout Description
on=1:1,off=0:1 is the complete specification, avoiding the use of defaults
\end_layout

\begin_layout Standard
Often several control signals or status signals share a single 8- or 16-bit
 memory location.
 In clockwork, each of the status bits is represented by a MACHINE object
 and the setup is managed by use of the OVERLAPS syntax.
 Given a control word defined like this:
\end_layout

\begin_layout LyX-Code

\size small
Control: xxxEMMMR
\end_layout

\begin_layout LyX-Code

\size small
Bits:    76543210
\end_layout

\begin_layout Standard
where x bits aren't used, E is the 'Enable' control bit and R is a 'Reset'
 command and MMM is a 3-bit 'Mode' value, clockwork can be configured as
 follows:
\end_layout

\begin_layout LyX-Code

\size small
# access the 1st component (an 8 bit value) of module1:
\end_layout

\begin_layout LyX-Code

\size small
control DIGITALOUTPUT(size:8) module1, 0; 
\end_layout

\begin_layout LyX-Code

\size small
enable FLAG OVERLAPS control.VALUE(offset:4);
\end_layout

\begin_layout LyX-Code

\size small
reset FLAG OVERLAPS control.VALUE(offset:0);
\end_layout

\begin_layout LyX-Code

\size small
mode DIGITALOUTPUT(size:3) OVERLAPS control.VALUE(offset:1);
\end_layout

\begin_layout Standard
With this configuration, the program can set mode.VALUE to any 3-bit value,
 i.e., a value from 0 (0x0) to 7 (0b111).
\end_layout

\begin_layout Subsubsection
Structured Data
\end_layout

\begin_layout Standard
TBD add details about structures, JSON and XML and transactions/atomic changes.
\end_layout

\begin_layout LyX-Code

\size small
OPTION value { x:0, y:0 }
\end_layout

\begin_layout LyX-Code

\size small
LOCK value;
\end_layout

\begin_layout LyX-Code

\size small
value.x := 3;
\end_layout

\begin_layout LyX-Code

\size small
value.y := 4;
\end_layout

\begin_layout LyX-Code

\size small
RELEASE value or perhaps COMMIT value (either would release the lock)
\end_layout

\begin_layout Standard
Should we use the 'WITHIN' syntax:
\end_layout

\begin_layout LyX-Code

\size small
WITHIN value x := 3, y:= 7;
\end_layout

\begin_layout Subsubsection
RECORDS
\end_layout

\begin_layout Standard
RECORDs in clockwork define ways to interpret blocks of memory and group
 properties togetherFor example, clockwork can load an XML file describing
 EtherCAT hardware into a structure that includes named elements and has
 a contiguous block of memory that maps to hardware I/O.
\end_layout

\begin_layout Standard
Records:
\end_layout

\begin_layout Itemize
have an offset
\end_layout

\begin_layout Itemize
have a size
\end_layout

\begin_layout Itemize
can contain metadata (properties)
\end_layout

\begin_layout Itemize
can contain other records
\end_layout

\begin_layout Itemize
fully contain child records (it is an error to declare a child that extends
 past the bounds of the parent) 
\end_layout

\begin_layout Itemize
may contain named or anonymous chunks of BIT, BYTE, WORD16, WORD32, WORD64
\end_layout

\begin_layout LyX-Code
Colour RECORD {
\end_layout

\begin_deeper
\begin_layout LyX-Code
r BYTE;
\end_layout

\begin_layout LyX-Code
g BYTE;
\end_layout

\begin_layout LyX-Code
b BYTE;
\end_layout

\end_deeper
\begin_layout LyX-Code
};
\end_layout

\begin_layout LyX-Code
Inputs RECORD (size: 8) {
\end_layout

\begin_deeper
\begin_layout LyX-Code
BIT[4]; # skip 4 bits
\end_layout

\begin_layout LyX-Code
in1 BIT;
\end_layout

\begin_layout LyX-Code
in2 BIT;
\end_layout

\begin_layout LyX-Code
in3 BIT;
\end_layout

\begin_layout LyX-Code
in4 BIT;
\end_layout

\end_deeper
\begin_layout LyX-Code
};
\end_layout

\begin_layout LyX-Code
Outputs RECORD (size: 8) {
\end_layout

\begin_deeper
\begin_layout LyX-Code
out1 BIT;
\end_layout

\begin_layout LyX-Code
out2 BIT;
\end_layout

\begin_layout LyX-Code
out3 BIT;
\end_layout

\begin_layout LyX-Code
out4 BIT;
\end_layout

\begin_layout LyX-Code
BIT[4]; # skip four bits
\end_layout

\end_deeper
\begin_layout LyX-Code
};
\end_layout

\begin_layout Standard
When records include other records it is possible to have them start at
 the same place using the '|' operator
\end_layout

\begin_layout LyX-Code
IO RECORD (size: 8) {
\end_layout

\begin_deeper
\begin_layout LyX-Code
Inputs | Outputs; # Inputs and Outputs start at the same location
\end_layout

\begin_layout LyX-Code
data BYTE[10]; # a 10 byte block following the above bits 
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
Records may overlap the same piece of memory.
 The name of a field may be unique across all records mapped over a memory
 location.
 In this case, it may be reasonable to allow use of the field name without
 qualification by record id.
 When a record is loaded, a symbol table that provides direct access to
 the offset and size of each field is built, for example the above might
 be initially loaded as:
\end_layout

\begin_layout LyX-Code
{IO: {Inputs: {in1:{offset:4,size:1},in2:{offset:5,size:1},...},Outputs:{out1:{offs
et:0,size:1},{offset:1,size:1},...},data:{offset:8,size:80}}}
\end_layout

\begin_layout Standard
This may then be converted to:
\end_layout

\begin_layout LyX-Code
{IO.Inputs.in1:{offset:4,size:1},in1:{offset:4,size:1},...
\end_layout

\begin_layout Standard
Thus, the bit at offset 4 can be found using 'IO.Inputs.in1' or simply 'in1'.
 Note that IO.Inputs doesn't really need to resolve since it isn't a single
 field.
 
\end_layout

\begin_layout Standard
In the case of EtherCAT, we can use the RECORD syntax to define the structures
 we need.
\end_layout

\begin_layout LyX-Code
Module RECORD {
\end_layout

\begin_deeper
\begin_layout LyX-Code
OPTION position 1;
\end_layout

\begin_layout LyX-Code
OPTION alias 0;
\end_layout

\begin_layout LyX-Code
pdo1 RECORD {
\end_layout

\begin_deeper
\begin_layout LyX-Code
OPTION SM 3;
\end_layout

\begin_layout LyX-Code
OPTION index 0x1a00;
\end_layout

\begin_layout LyX-Code
OPTION name “Inputs”;
\end_layout

\begin_layout LyX-Code
RECORD {
\end_layout

\begin_deeper
\begin_layout LyX-Code
INITIAL 0; # this can also be done via a prepare statement
\end_layout

\begin_layout LyX-Code
RECORD { # unnamed map, this is the default interpretation for this region
\end_layout

\begin_deeper
\begin_layout LyX-Code
BIT[3];
\end_layout

\begin_layout LyX-Code
valve BIT;
\end_layout

\begin_layout LyX-Code
motor BIT;
\end_layout

\begin_layout LyX-Code
BIT[3]; # avoid warnings by labelling all 8 bits
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
byte BYTE; // a named map, pdo1.byte interprets the region as a single byte
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\begin_layout Subsubsection
Constrained Data
\end_layout

\begin_layout Standard
See LET.
\end_layout

\begin_layout Standard

\size small
CONSTRAIN x,y : y := x+ 5;
\size default
 # this would iteratively attempt to solve for x.
 
\end_layout

\begin_layout Standard
Should we add EQUIVALENT (better name?) clauses:
\end_layout

\begin_layout Standard

\size small
CONSTRAIN x,y : y := x + 5 EQUIVALENT x := y - 5;
\end_layout

\begin_layout Standard
If there is no solution for a constraint, an error is raised.
\end_layout

\begin_layout Subsubsection
Persistence
\end_layout

\begin_layout Standard
Currently persistence is a hack using a property `PERSISTENT' that causes
 a machine to announce statue or property changes on a persitence channel
 whenever a change occurs.
 This is to be upgraded to become a feature of the language and the following
 clauses will be added:
\end_layout

\begin_layout Description
PERSISTENT means that the machine is persistent and all properties within
 the machine are saved in the persistent store if enabled at runtime.
 For backward compatibility the PERSISTENT property is still supported for
 this purpose.
\end_layout

\begin_layout Description
VOLATILE means that the given property is not included in the persistent
 properties of a machine so these values are not written to the persistence
 store
\end_layout

\begin_layout Description
PRIVATE means that the named state is not visible outside of the machine
 (even to sub-machines) and it is not published on any channel unless the
 channel includes a specific option to include private objects (persistence,
 samplers and debuggers may include private properties for example)
\end_layout

\begin_layout Description
LOCAL means that the named option is not published on any channel unless
 the channel includes a specific option to include local properties.
 Local properties are still accessible to other machines.
\end_layout

\begin_layout Subsection
Clocking
\end_layout

\begin_layout Standard
Sometimes it is useful to perform actions are regular intervals and for
 several actions to be synchronised.
 To provide this facility, clockwork uses the notion of a CLOCK that triggers
 a timer event at regular intervals.
\end_layout

\begin_layout LyX-Code
CLOCK MACHINE {
\end_layout

\begin_deeper
\begin_layout LyX-Code
OPTION rate 1000; # milliseconds
\end_layout

\begin_layout LyX-Code
started FLAG;
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
tick WHEN SELF IS wait && TIMER = rate;
\end_layout

\begin_layout LyX-Code
wait WHEN started IS on;
\end_layout

\begin_layout LyX-Code
idle DEFAULT;
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
COMMAND start { SET started TO on; }
\end_layout

\begin_layout LyX-Code
COMMAND stop { SET started TO off; }
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
Machines that are synchronised to a clock receive tick events:
\end_layout

\begin_layout LyX-Code
Reader MACHINE input, clock {
\end_layout

\begin_deeper
\begin_layout LyX-Code
OPTION value 0.0;
\end_layout

\begin_layout LyX-Code
RECEIVE clock.tick_enter { value = input.VALUE; }
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
Should we add syntactic sugar:
\end_layout

\begin_layout LyX-Code
read_clock CLICK(rate: 100);
\end_layout

\begin_layout LyX-Code
Reader MACHINE input, clock {
\end_layout

\begin_deeper
\begin_layout LyX-Code
OPTION value 0;
\end_layout

\begin_layout LyX-Code
ON clock.tick { valuie := input.VALUE; }
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
Define an interface for CLOCK and link it to an analogue input
\end_layout

\begin_layout LyX-Code
ClockInterface INTERFACE {
\end_layout

\begin_deeper
\begin_layout LyX-Code
STATES { idle, tick, wait }
\end_layout

\begin_layout LyX-Code
COMMANDS {start, stop }
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
ain ANALOGUEINPUT (clock: read_clock = SYSTEM.READ_CLOCK) {
\end_layout

\begin_deeper
\begin_layout LyX-Code
clock IMPLEMENTS ClockInterface;
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\begin_layout Subsection
Lists
\end_layout

\begin_layout Standard
Procedural or functional style? A functional language tends to use functions
 such as car and cdr.
 Similar to sets, it should be possible to enumerate objects and also to
 receive events as items are added or removed from the list.
\end_layout

\begin_layout Subsection
Data hiding
\end_layout

\begin_layout Standard
Add: check PRIVATE STATE WITHIN visible_alias or perhaps just PRIVATE STATE
 that simply doesn't update the external view of what state the machine
 is in.
 Also consder aliasing perhaps 
\size small
SHOW state_name1 FOR state_name2.
\end_layout

\begin_layout Subsection
Type checking
\end_layout

\begin_layout Standard
Consider adding: sample MACHINE p1 class1, p2 class2
\end_layout

\begin_layout Subsection
Substates
\end_layout

\begin_layout Subsection
Exceptions
\end_layout

\begin_layout Standard
Exceptions are messages that are broadcast to several receivers, based on
 whether they CATCH the event or not.
 An exception is sent by the THROW command and this command causes a handler
 to abort at point the exception is sent.
 I would like to consider the option of temporarily listening for events,
 including exceptions and this is likely to be done via a LISTEN command
 to enable listening and an IGNORE command to disable listening.
 By default, if a machine implements an event handler for an event it is
 assumed to be listening for the event.
 
\end_layout

\begin_layout Subsection
Conditions
\end_layout

\begin_layout Standard
Conditions are not currently implemented but they are intended to operate
 as shortcuts or optimisations that reduce the need to have a large set
 of expressions on WHEN clauses.
 Effectively, a CONDITION is a machine that is true when the expression
 is true and false otherwise.
 Conditions are evaluated before stable state tests and are guaranteed to
 be valid throughout the test process.
\end_layout

\begin_layout Standard
A condition is instantiated just like a machine except that the final parameter
 is a boolean expression within braces.
 For example:
\end_layout

\begin_layout LyX-Code
door_open CONDITION prox { prox IS on }
\end_layout

\begin_layout Subsection
Error handling
\end_layout

\begin_layout Standard
Clockwork 1.0 introduces exception and error handling
\end_layout

\begin_layout LyX-Code

\size small
TRY {
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
statement-list
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout LyX-Code

\size small
WHEN TIMER >= timeout {
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
ABORT; # unsuccessful completion
\end_layout

\begin_layout LyX-Code

\size small
RETURN; # successful completion 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout LyX-Code

\size small
CATCH message {
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
LOG 
\begin_inset Quotes eld
\end_inset

Error: 
\begin_inset Quotes eld
\end_inset

 + message + 
\begin_inset Quotes eld
\end_inset

 detected
\begin_inset Quotes erd
\end_inset


\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard
TBD how should this be used to enable validation when done?
\end_layout

\begin_layout Standard
In addition, certain statements add ON ERROR and ON TIMEOUT clauses that
 can be used separately ot together.
\end_layout

\begin_layout LyX-Code

\size small
SET machine TO state ON ERROR { ...
 }
\end_layout

\begin_layout LyX-Code

\size small
CALL handler ON machine ON ERROR { ...
 }
\end_layout

\begin_layout LyX-Code

\size small
SET machine TO state ON TIMEOUT n { ...
 }
\end_layout

\begin_layout LyX-Code

\size small
CALL handler ON machine ON TIMEOUT n { ...
 }
\end_layout

\begin_layout Standard
Errors may be generic, as above, where the one error handler will handle
 all errors from the statement or my be specific where the error is generated
 with the handler and caught in the ON ERROR.
 In the following example, the handler may return different application
 specific errors and the CALL of the handler can deal with each error with
 a specific block.
\end_layout

\begin_layout LyX-Code

\size small
COMMAND handler { IF ...
 ERROR error1; ...
 ELSE...
 ERROR error2; ...
 }
\end_layout

\begin_layout LyX-Code

\size small
CALL handler 
\end_layout

\begin_layout LyX-Code

\size small
ON machine ON ERROR error1 { ....
 } ON ERROR error2 { ...
 }
\end_layout

\begin_layout Standard
If necessary a handler can THROW a message and another part of the machine
 can CATCH it
\end_layout

\begin_layout LyX-Code

\size small
COMMAND handler { ...; THROW error_name; ...
 }
\end_layout

\begin_layout LyX-Code

\size small
...
\end_layout

\begin_layout LyX-Code

\size small
CATCH error_name { ...
 }
\end_layout

\begin_layout Standard
Rather than having a single CATCH within the machine, an error handler may
 be specified on the CALL:
\end_layout

\begin_layout LyX-Code

\size small
CALL handler ON machine ON error1 {...} ON error2 {...}
\end_layout

\begin_layout LyX-Code

\size small
COMMAND handler { ...
 THROW error1; ...
 }
\end_layout

\begin_layout Standard
Note that statements after a THROW are not executed and the handler is deemed
 to have failed.
 An ON ERROR will catch a THROWn error but it will also be caught by matching
 CATCHers.
 The special name ALL can be used with a CATCH to catch every THROWn message:
\end_layout

\begin_layout LyX-Code

\size small
CATCH ALL { num_errors := num_errors + 1 }
\end_layout

\begin_layout Subsection
State changes
\end_layout

\begin_layout Standard
We have clarified what is meant by 
\begin_inset Quotes eld
\end_inset

machine IS state
\begin_inset Quotes erd
\end_inset

 to mean that the conditions for that state are true and the machine has
 completed the transition to the state.
 Once a machine has started to change state, it enters a private 
\begin_inset Quotes eld
\end_inset

leaving
\begin_inset Quotes erd
\end_inset

 state for the previous state and then a private 
\begin_inset Quotes eld
\end_inset

entering
\begin_inset Quotes erd
\end_inset

 state for the new state before finally becoming on.
 Since they are private states, the machine will appear to the outside world
 to still be in the original state.
\end_layout

\begin_layout Standard
Two new verbs are added: LEAVING and ENTERING, these can be used to get
 access to the private parts of the transition.
\end_layout

\begin_layout Standard
Is a transitional state equal to a normal state with the same name?
\end_layout

\begin_layout Standard
is a private state equal to a normal state with the same name?
\end_layout

\begin_layout Standard
PRIVATE states can be used to simplify the external interface of a machine.
\end_layout

\begin_layout LyX-Code

\size small
turning_on PRIVATE STATE;
\end_layout

\begin_layout LyX-Code

\size small
on STATE;
\end_layout

\begin_layout LyX-Code

\size small
PRIVATE STATES a,b,c;
\end_layout

\begin_layout Standard
To indicate that a stable state is private the state needs to be declared
 as a PRIVATE STATE as well as being defined in a WHEN clause in the normal
 way.
\end_layout

\begin_layout Standard
Consider simply setting 'transitional' on a state during the enter/leave
 process.
\end_layout

\begin_layout Standard
Consider adding a new test to see if a machine is currently transitioning:
 wait WHEN other IS CHANGING STATE;
\end_layout

\begin_layout Standard
As part of this cleanup, some work needs to be done on the current implementatio
n of USING.
 At present, given
\end_layout

\begin_layout Standard

\size small
TRANSITION a TO b USING next;
\end_layout

\begin_layout Standard
will provide a command called 'next' that causes a transition from 'a' to
 'b'.
 This will also cause an effect whereby if the machine moves from 'a' to
 'b' by a direct 'SET', the next command will still be executed.
 A new verb is required to specifically enable this behaviour:
\end_layout

\begin_layout Standard

\size small
TRANSITION a TO b USING next;
\size default
 # retains the legacy behaviour
\end_layout

\begin_layout Standard

\size small
TRANSITION a TO b AFTER next; 
\size default
# the 'next' command causes the transition once the 'next' method completes
\end_layout

\begin_layout Standard

\size small
TRANSITION a TO b INVOKES starting;
\size default
 # the 'starting' handler is invoked after the machine transitions from
 a to b
\end_layout

\begin_layout Standard
The two clauses can be combined.
\end_layout

\begin_layout Subsection
Support of parallel execution
\end_layout

\begin_layout Standard
The most direct method to support parallel execution is to identify separate
 chains of dependency within the machine graph.
 Thus, for example, changes that occur in one input may be able to be completely
 processed in parallel with another chain if the steps are independent of
 changes that occur in another input.
 [yuk reword]
\end_layout

\begin_layout Standard
More explanation required
\end_layout

\begin_layout Subsection
Type Extensions
\end_layout

\begin_layout Standard
Type extensions provide for adding parameters, statements to the handlers
 within a state machine, fields and substates.
\end_layout

\begin_layout LyX-Code

\size small
A MACHINE { \SpecialChar ldots
 };
\end_layout

\begin_layout LyX-Code

\size small
B MACHINE EXTENDS A <additional parameters> {
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout LyX-Code

\size small
<event handler extensions>
\end_layout

\begin_layout LyX-Code

\size small
<additional fields>
\end_layout

\begin_layout LyX-Code

\size small
<state extensions>
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard
More thought is required here, what I am planning is that clauses within
 B can be defined as separate or as extensions of those in A, for example
 INIT { ...
 } simply defines a handler for the INIT state in B.
 Whereas INIT EXTENDS A.INIT { ...
 } defines extra steps that are added to the handler already defined in
 A.
\end_layout

\begin_layout Standard
When a MACHINE is extended, all instances of the object share default properties
 of the extended type unless they are explicitly added for the derived machine.
\end_layout

\begin_layout Subsection
Protocols
\end_layout

\begin_layout Standard
Protocols can be used to ensure that machines passed as parameters actually
 provide the correct facilities.
 A machine can conform to multiple protocols.
\end_layout

\begin_layout LyX-Code

\size small
switch PROTOCOL { STATES { on, off; } COMMANDS {turnOn, turnOff} }
\end_layout

\begin_layout LyX-Code

\size small
controller MACHINE on_off<switch> { ...
 }
\end_layout

\begin_layout Standard
In the above, the machine passed to the controller will be required to have
 only a state 'on' and a state 'off' and support the turnOn and turnOff
 commands.
\end_layout

\begin_layout Standard
If the switch is to be also allowed to have other states or commands we
 would describe it:
\end_layout

\begin_layout LyX-Code

\size small
switch PROTOCOL { STATES { on, off, ...; } COMMANDS {turnOn, turnOff, ...} }
\end_layout

\begin_layout Standard
TBD
\end_layout

\begin_layout Subsection
Data access
\end_layout

\begin_layout Standard
Data is often modified during a process but it is not appropriate for external
 monitors to see data until it is in a stable state.
 The intention is to add a facility that can be used to perform data calculation
s using internal, private instances and to only make the data available
 externally in certain states.
 See LOCAL, PRIVATE.
\end_layout

\begin_layout Subsection
Date and Time functions
\end_layout

\begin_layout Standard
Note that these properties cannot be used in WHEN clauses of automatic states
 since they do not generate events as they change.
\end_layout

\begin_layout Description
NOW the current time in milliseconds
\end_layout

\begin_layout Description
DAY the number of the current day (1..31)
\end_layout

\begin_layout Description
MONTH the number of the current month (1..12)
\end_layout

\begin_layout Description
YR the current year (two digits)
\end_layout

\begin_layout Description
YEAR the curren tyear (four digits)
\end_layout

\begin_layout Description
HOUR the current hour (0..23)
\end_layout

\begin_layout Description
MIN the current minute within the hour (0..59)
\end_layout

\begin_layout Description
SEC the current second within the current minute (0..59)
\end_layout

\begin_layout Standard
Retriggering of subcondition; syntax:
\end_layout

\begin_layout LyX-Code

\size small
state WHEN condition,
\end_layout

\begin_layout LyX-Code

\size small
EXECUTE method WHENEVER condition, 
\end_layout

\begin_layout LyX-Code

\size small
TAG machine WHENEVER condition,
\end_layout

\begin_layout LyX-Code

\size small
EXECUTE/DO method EVERY duration;
\end_layout

\begin_layout Subsection
Frequency Calculation
\end_layout

\begin_layout Standard
All single bit inputs have the option of having their cycle frequency calculated.
 The simplest method for this is to record the number of cycles of the input
 state over a period of time.
 There is no need to perform the calculation of 
\begin_inset Formula $\frac{cycle}{time}$
\end_inset

 until the frequency data is actually needed.
 A clever algorithm will be used to ensure that the counter and time period
 values use sensible ranges (eg per sec, per msec etc).
\end_layout

\begin_layout Standard
Initially no attempt will be made to identify input frequency for analogue
 inputs.
\end_layout

\begin_layout Subsection
Priorities
\end_layout

\begin_layout Standard
A machine will be able to be given a priority or a polling rate to indicate
 that events for this machine are to be handled more or less frequently
 than other machines
\end_layout

\begin_layout Subsection
Cycle Time
\end_layout

\begin_layout Standard
The program must be able to be configured to use a faster or slower cycle
 time in order to save power on small devices and to give better performance
 when dealing with demanding tasks.
\end_layout

\begin_layout Subsection
Input polling
\end_layout

\begin_layout Standard
Currently the machine follows a cycle that is input-process-output on a
 fixed clock.
 The new design pushes work to be done onto a processing queue and that
 processing queue operates until the cycle time arrives and then performs
 a read/update cycle to the IO.
 
\end_layout

\begin_layout Standard
This approach must buffer incoming data in order to prevent invalid state
 processing on machine with automatic states.
 This will be done by marking some tasks as high priority such that these
 tasks but be performed every cycle.
 Further thought is required.
\end_layout

\begin_layout Subsubsection
Command Polling
\end_layout

\begin_layout Standard
A subcondition can be used to repeat an action only while a machine is in
 a particular state:
\end_layout

\begin_layout LyX-Code
EXECUTE / DO command EVERY time_period;
\end_layout

\begin_layout Standard
Consider adding this with a standalone syntax also: 
\end_layout

\begin_layout LyX-Code
EXECUTE / DO command EVERY time_period [WITHIN state];
\end_layout

\begin_layout Subsection
Property calculations
\end_layout

\begin_layout Standard
OPTION x expession
\end_layout

\begin_layout Subsection
Dynamic machines
\end_layout

\begin_layout Standard
New machines can be constructed with the CREATE command and removed with
 the DESTROY command.
 An object cannot be destroyed if it is being used within another object
 (ie it has dependencies) or is passed to another object, it needs to be
 either removed from that object or that object must first be destroyed.
 Automatic reference counting is used so that when objects leave scope they
 are automatically destroyed.
\end_layout

\begin_layout Standard
Objects that are allocated statically can never be destroyed and reference
 counting is not necessary for these items (it may still be applied, however..TBD)
\end_layout

\begin_layout Subsection
Linked states
\end_layout

\begin_layout Standard
States in cooperating machines can be linked to ensure that one machine
 passes through a gateway state before another machine may pass through
 a linked state.
\end_layout

\begin_layout Subsection
Patterns
\end_layout

\begin_layout Standard
Access parts of a pattern via COPY pattern FROM source TO list
\end_layout

\begin_layout Subsection
Extensions
\end_layout

\begin_layout Standard
New machine types can be defined by loadable modules.
 A loadable module is required to provide a particular interface that is
 used when instances of objects from that module are processed.
 It may be possible to provide loadable objects using a messaging or rpc
 interface.
 (TBD)
\end_layout

\begin_layout Subsubsection
Defining PDOs
\end_layout

\begin_layout Subsubsection
The EtherCAT extension
\end_layout

\begin_layout Standard
This extension provides an object of type EtherCAT_Entry when instantiated,
 this machine registers a pdo entry with ethercat, using the details provided.
 The extension also adds an SDO object for performing SDO functions.
 Note that currently this is hard-coded into the interpreter.
 
\end_layout

\begin_layout Subsubsection*
Using SDO within Clockwork
\end_layout

\begin_layout Standard
To add an SDO entry, add an instance of a machine with class SDOENTRY in
 the clockwork configuration.
 The parameters of an SDOENTRY are:
\end_layout

\begin_layout Description
module the clockwork name for the EtherCAT module that the entry is in
\end_layout

\begin_layout Description
index the index value of the entry
\end_layout

\begin_layout Description
subindex the subindex value of the entry
\end_layout

\begin_layout Description
size the size (in bytes) of the entry (TBD fix this and implement support
 for single bit SDO entries)
\end_layout

\begin_layout Standard
The object has a VALUE property that can be set and read within the code
 and an IOTIME that indicates the last time the entry was read from the
 io hardware.
 A `default' property can also be set to indicate that this entry is to
 be initialised before the control logic is given access to the hardware.
\end_layout

\begin_layout Subsection
Type Extensions
\end_layout

\begin_layout Standard
Machines should be able to be defined as extensions of existing machines.
 Initially these extensions will only be able to add actions and commands.
 Some thought will be needed as to whether actions will be executed before
 or after existing actions.
 
\end_layout

\begin_layout Subsection
Introspection
\end_layout

\begin_layout Standard
Clockwork already has facilities to enable and disable parts of the executing
 machine.
 To make it easier to address groups of machines some facilities will be
 added tselect machines within the current instance:
\end_layout

\begin_layout LyX-Code

\size small
points LIST FROM SELECT MACHINES OF TYPE POINT;
\end_layout

\begin_layout LyX-Code

\size small
outputs LIST FROM SELECT MACHINES WITH NAME MATCHING `^O_`;
\end_layout

\begin_layout Standard
or 
\end_layout

\begin_layout LyX-Code

\size small
points LIST;
\end_layout

\begin_layout LyX-Code

\size small
SELECT MACHINES OF TYPE POINT INTO points;
\end_layout

\begin_layout Subsection
Macros
\end_layout

\begin_layout Standard
Macros replace a tagged section of the program with a user-defined scrap
 of text, optionally substituting text in the process.
 All characters are copied literally, including line breaks, spaced and
 tab characters.
 [TBD should we instead trim leading and trailing whitespace and include
 a single space between entries when updating a macro definition?]
\end_layout

\begin_layout Standard
A macro has the form:
\end_layout

\begin_layout LyX-Code

\size small
DEFINE name [ '(' name1 [ ',' name1 ]...
 ')' ] '{' text '}'
\end_layout

\begin_layout Standard
Within the text, name1, name2 etc are replaced with the values provided
 where the macro is to be expanded.
\end_layout

\begin_layout Standard
To introduce a macro use:
\end_layout

\begin_layout LyX-Code

\size small
DEFINE sum(a,b) { a + b }
\end_layout

\begin_layout Standard
To expand the macro, use the name and parameters part of the above:
\end_layout

\begin_layout LyX-Code

\size small
three := sum(1,2);
\end_layout

\begin_layout Standard
A macro name may include spaces and if desired, the expansion may include
 expansion markers '@<' and '@>' to make it clear that a macro is being
 used.
 For example:
\end_layout

\begin_layout LyX-Code

\size small
DEFINE initialise the variables { x := 0; }
\end_layout

\begin_layout LyX-Code

\size small
...
\end_layout

\begin_layout LyX-Code

\size small
ENTER INIT { @<initialise the variables@> }
\end_layout

\begin_layout Standard
Note that it is perfectly fine to write the following
\end_layout

\begin_layout LyX-Code

\size small
DEFINE initialise the variables { x := 0; }
\end_layout

\begin_layout LyX-Code

\size small
...
\end_layout

\begin_layout LyX-Code

\size small
ENTER INIT { initialise the variables }
\end_layout

\begin_layout Standard
Unlike other macro systems, in clockwork a macro can be reintroduced and
 this simply adds the extra text to the macro expansion.
 All macros are collected throughout the source before expansion begins
 so this feature can be used to reorder the program to suit the reader if
 desired.
 For example, the above example might have been:
\end_layout

\begin_layout LyX-Code

\size small
DEFINE initialise the variables { x := 0; }
\end_layout

\begin_layout LyX-Code

\size small
...
\end_layout

\begin_layout LyX-Code

\size small
DEFINE initialise the variables { y := 0; }
\end_layout

\begin_layout LyX-Code

\size small
...
\end_layout

\begin_layout LyX-Code

\size small
ENTER INIT { @<initialise the variables@> }
\end_layout

\begin_layout Standard
In which case, the INIT method would have expanded to
\end_layout

\begin_layout LyX-Code

\size small
ENTER INIT { x:=0;  y:=0; }
\end_layout

\begin_layout LyX-Code

\end_layout

\end_body
\end_document
