#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 1cm
\topmargin 1cm
\rightmargin 1cm
\bottommargin 2cm
\headheight 1cm
\headsep 1cm
\footskip 1cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
The Future of the Clockwork Programming Language
\end_layout

\begin_layout Author
Martin Leadbeater
\end_layout

\begin_layout Abstract
This paper describes various language features that will be added to Clockwork
 in the future
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Subsection
Types
\end_layout

\begin_layout Itemize
Integers
\end_layout

\begin_layout Itemize
Strings
\end_layout

\begin_layout Itemize
Floating point calculations
\end_layout

\begin_layout Itemize
Binary values
\end_layout

\begin_layout Itemize
Sets and relationships
\end_layout

\begin_layout Itemize
Lists
\end_layout

\begin_layout Itemize
References
\end_layout

\begin_layout Itemize
Type conversions (x AS type)
\end_layout

\begin_layout Subsubsection
Not implemented
\end_layout

\begin_layout Itemize
Streams (also generators)
\end_layout

\begin_layout Itemize
Replace the current symbol table and Value system with a more efficient
 and robust implementation
\end_layout

\begin_layout Itemize
Type extensions 
\end_layout

\begin_layout Itemize
Records/Property Sets
\end_layout

\begin_layout Subsection
Data
\end_layout

\begin_layout Itemize
Sharing properties or data
\end_layout

\begin_layout Itemize
Events with data
\end_layout

\begin_layout Itemize
Copying properties en mass via variants of COPY PROPERTIES
\end_layout

\begin_layout Subsection
Features
\end_layout

\begin_layout Itemize
Substates (implemented via nesting of machines)
\end_layout

\begin_layout Itemize
Exceptions (THROW, CATCH)
\end_layout

\begin_layout Itemize
Conditions
\end_layout

\begin_layout Itemize
Processing priorities - low priority/slow scan inputs
\end_layout

\begin_layout Itemize
Functions
\end_layout

\begin_layout Itemize
External function calls
\end_layout

\begin_layout Itemize
Dynamic allocation (ie creating and destroying data items)
\end_layout

\begin_layout Itemize
Dynamic configuration (creating and destroying machines)
\end_layout

\begin_layout Itemize
Modular/dynamic components
\end_layout

\begin_layout Itemize
Support of parallel execution
\end_layout

\begin_layout Itemize
Controlling safe access to data - stable and changing property states, dynamic
 data privacy
\end_layout

\begin_layout Itemize
Method extensions
\end_layout

\begin_layout Itemize
Sequences and Cycles - shortcuts for transition tables? Transitions are
 limited to be within a list or a cycle of states.
\end_layout

\begin_layout Itemize
Threaded implementation
\end_layout

\begin_layout Itemize
Executing a subexpression on the default state
\end_layout

\begin_layout Itemize
Persistence via persistd
\end_layout

\begin_layout Itemize
Property type and state enforcement via STRICT
\end_layout

\begin_layout Subsubsection
Not implemented
\end_layout

\begin_layout Itemize
Macros
\end_layout

\begin_layout Subsection
Bugs
\end_layout

\begin_layout Itemize
Passing SELF to an internal object
\end_layout

\begin_layout Itemize
Stable states that use timers of other machines (retest)
\end_layout

\begin_layout Itemize
State changes during stable state evaluation (details?)
\end_layout

\begin_layout Subsection
Communication
\end_layout

\begin_layout Itemize
Communication between instances of clockwork drivers
\end_layout

\begin_layout Itemize
Global configuration (eg timer range in usec, msec, sec)
\end_layout

\begin_layout Itemize
Formal/scrict interfaces
\end_layout

\begin_layout Itemize
sending data with a message
\end_layout

\begin_layout Itemize
holding messages that arrive outside the state where they can be used
\end_layout

\begin_layout Itemize
limiting execution of commands apart from in certain states
\end_layout

\begin_layout Subsection
Modules
\end_layout

\begin_layout Itemize
PID controls - ramps, constant speed
\end_layout

\begin_layout Itemize
Counter inputs
\end_layout

\begin_layout Itemize
Frequency inputs (calculated or read from advanced devices)
\end_layout

\begin_layout Itemize
Low level module initialisation
\end_layout

\begin_layout Itemize
Bus change events
\end_layout

\begin_layout Itemize
CAN objects for paramaterisation
\end_layout

\begin_layout Subsection
Time
\end_layout

\begin_layout Itemize
Delayed messaging (sending messages after a delay and cancelling..)
\end_layout

\begin_layout Itemize
Wall time (long period timers)
\end_layout

\begin_layout Itemize
Polling - repeatedly executing a statement
\end_layout

\begin_layout Itemize
Retriggering EXECUTE / TAG actions
\end_layout

\begin_layout Subsection
Macros
\end_layout

\begin_layout Standard
Macros provide a way to restructure the source into a form that improved
 readability.
 The macro facilty is simply a string replacement with the ability to substitute
 variables within the string as it is inserted.
\end_layout

\begin_layout Subsection
Dynamic instantiation
\end_layout

\begin_layout Standard
Since machines are defined statically there is no way to create a new machine
 or destroy one that is not needed.
 The language uses properties to store values and although machines can
 be named, there is no way to make a property that refers to a machine.
 It is not even possible to save the state of a machine and restore that
 state later.
 [this is changing (see LIST), TBD]
\end_layout

\begin_layout Section
Feature discussion
\end_layout

\begin_layout Standard
Clockwork is currently based around the notion of machines, states and propertie
s.
 Machines cannot carry data per-se but since the property system provides
 for simple key-value objects, the effect can be simulated at a basic level.
 Machines also need the notion of a working-set of data that is being processed
 or held.
 Traditionally data is grouped into 'structure's or 'object's and these
 terms and their common usage seems fine.
 More generally, a 'working set', if we chose to use the term, would refer
 to a collection of various values, structures and objects.
\end_layout

\begin_layout Subsection
Value system
\end_layout

\begin_layout Standard
The way property values are stored in machines desparately needs an overhaul;
 the current system is build on a C type structure and uses runtime type
 comparions.
 A new version will use C++ virtual methods that bind functions at compile
 time.
\end_layout

\begin_layout Subsubsection
Floating point values
\end_layout

\begin_layout Standard
Within clockwork, floating point values are used as in the following examples:
\end_layout

\begin_layout LyX-Code
OPTION x 1.0;
\end_layout

\begin_layout LyX-Code
OPTION y 1.;
\end_layout

\begin_layout LyX-Code
OPTION z 1.3E3;
\end_layout

\begin_layout Standard
Usage
\end_layout

\begin_layout LyX-Code
OPTION a 1;
\end_layout

\begin_layout LyX-Code
OPTION x 1.3;
\end_layout

\begin_layout LyX-Code
a := a + x; /* a converted to float with value 2.3 */
\end_layout

\begin_layout LyX-Code
a := INT(a+x); /* INT is an alias for INTEGER */
\end_layout

\begin_layout LyX-Code
a := a + x AS INTEGER;
\end_layout

\begin_layout LyX-Code
a := (a + x) AS INTEGER;
\end_layout

\begin_layout Standard
The precedence of AS is 
\end_layout

\begin_layout Subsubsection
Type translation
\end_layout

\begin_layout Standard
Values are typed internally and can be forcibly converted from one type
 to another via the AS operator:
\end_layout

\begin_layout LyX-Code
a := b AS INTEGER;
\end_layout

\begin_layout LyX-Code
b := a AS FLOAT
\end_layout

\begin_layout Standard
Numeric values can be combined in expressions without specific type casting
 and the rules for determining resultant types are:
\end_layout

\begin_layout Itemize
string expressions cause numeric values to be converted to strings in the
 result
\end_layout

\begin_layout Itemize
when a floating point value is used in an subexpression, the subexpression
 type is converted to floating point
\end_layout

\begin_layout Itemize
floating point values will be displayed in fixed-point notation from clockwork
 (hard-coded at 3 decimal places at present
\end_layout

\begin_layout Subsection
Sets and relationships
\end_layout

\begin_layout Standard
We need to decide whether bits that are allocated to symbols should be allocated
 in least-significant or most-significant order.
 Perhaps a mapping function should be used (like a C union), with this in
 mind, defining three symbols, x,y and z to a block of bits would map bit
 2 to x, bit 1 to y and bit 0 (least significant) to z.
 This gives a nice mapping for those who visualise the bits in a block and
 want to map the symbols over the block.
\end_layout

\begin_layout LyX-Code
cutter1 Cutter;
\end_layout

\begin_layout LyX-Code
cutter2 Cutter;
\end_layout

\begin_layout LyX-Code
B BITSET [a,b,c,d]; # defines symbols a..d for bits 0..3
\end_layout

\begin_layout LyX-Code
C BITSET [r:8,g:8,b:8]; # defines symbols r,g and b for bits 0..23 of C
\end_layout

\begin_layout LyX-Code
INCLUDE a,d IN B
\end_layout

\begin_layout LyX-Code
x := B AS INTEGER;
\end_layout

\begin_layout LyX-Code
cutters SET[cutter1, cutter2];
\end_layout

\begin_layout LyX-Code
s INCLUDES? [a,b,c];
\end_layout

\begin_layout LyX-Code
SELECT state_name/value FROM set_name;
\end_layout

\begin_layout Standard
Sets could be implemented as a machine where each combination of members
 is a distinct state there doesn't seem to be much value in this.
 It may be useful to use three states: empty, nonempty and full.
\end_layout

\begin_layout Standard
Statements involving sets may be classified by whether they refer to the
 set itself, for example `INCLUDE 3 IN s', or the members.
 
\end_layout

\begin_layout Standard
Sets can be used in expressions in the following ways
\end_layout

\begin_layout Itemize
ANY IN set_name ARE | IS state_name # returns true if any of the items in
 the set are in the state given
\end_layout

\begin_layout Itemize
ANY PROPERTY property IN set_name ARE | IS value
\end_layout

\begin_layout Itemize
ALL IN set_name ARE | IS state_name/value
\end_layout

\begin_layout Itemize
ALL PROPERTY property_name IN set_name ARE | IS state_name/value
\end_layout

\begin_layout Itemize
COUNT state_name FROM set_name # counts the number of items in the set that
 are in the named state
\end_layout

\begin_layout Itemize
COUNT WHERE expression FROM set_name # counts the number of items in the
 set where the expression returns true 
\end_layout

\begin_layout Itemize
BITSET FROM set_name state_name # returns a bitset that represents the an
 on/off value for the given state name.
 Further examples use variable values..
\end_layout

\begin_layout Itemize
COPY n FROM set_name # picks n elements at random from a set
\end_layout

\begin_layout Itemize
TAKE n FROM set_name # takes n elements at random from a set
\end_layout

\begin_layout Subsubsection
Special Sets
\end_layout

\begin_layout Description
ALL [MACHINES]
\end_layout

\begin_layout Description
ENABLED [MACHINES]
\end_layout

\begin_layout Description
CHANNELS a list of all channels
\end_layout

\begin_layout Subsubsection
Operators
\end_layout

\begin_layout Description
CLASS
\end_layout

\begin_layout Subsubsection
Enumeration
\end_layout

\begin_layout Standard
There should be a way to trigger events for each item in a set: 
\end_layout

\begin_layout LyX-Code
EACH item IN set DO command
\end_layout

\begin_layout Standard
at present, a message can be sent to all members of a set by sending the
 message to the set
\end_layout

\begin_layout Subsubsection
Events
\end_layout

\begin_layout Standard
Sets should send messages on state change between empty, nonempty and full.
 It may be useful to send events as each item enters/leaves but at this
 point that seems excessive and of little value.
\end_layout

\begin_layout Subsubsection
Property Sets
\end_layout

\begin_layout Standard
Property Sets are groups of property names that can be used to initialise
 machines or used to change the value of several properties at the same
 time.
\end_layout

\begin_layout Standard
Initialising a machine will look somthing like:
\end_layout

\begin_layout LyX-Code
Sample MACHINE WITH (a:1, b:
\begin_inset Quotes erd
\end_inset

test
\begin_inset Quotes erd
\end_inset

) { ...
 }
\end_layout

\begin_layout Standard
or 
\end_layout

\begin_layout LyX-Code
my_properties PROPERTY_SET {
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout LyX-Code
OPTION a 1;
\end_layout

\begin_layout LyX-Code
OPTION b 
\begin_inset Quotes eld
\end_inset

test
\begin_inset Quotes erd
\end_inset

;
\end_layout

\begin_layout LyX-Code
OPTION c REFER TO a.b; ## the when update is used the target machine will
 read its c value from its local/param a.b
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
Sample MACHINE WITH my_properties { ...
 }
\end_layout

\begin_layout Standard
Property sets can be updated from a database:
\end_layout

\begin_layout LyX-Code
COLLECT record FROM data_source INTO my_properties ON ENDOFDATA done;
\end_layout

\begin_layout LyX-Code
UPDATE my_machine WITH my_properties [EXCLUDING name_list];
\end_layout

\begin_layout LyX-Code
UPDATE my_machine WITH [name_list FROM] my_properties
\end_layout

\begin_layout Standard
When a Property Set is being applied it is the changes are made to an invisible
 data structure linked to the property set.
 Once all of the invisible data values are updated the values are applied
 into the machine and a property_change event is triggered.
\end_layout

\begin_layout Standard
A normal property change that is executed while a property set is being
 update will be handled as normal.
 If that change updates a property that is changing within the Property
 Set the changed value will be lost on completion of the change.
 The effect is that the property assignments might occur out of order.
\end_layout

\begin_layout Standard
Property Set changes may be performed against shadowed data and the update
 will not occur until all properties are synchronised at both ends of the
 channel.
\end_layout

\begin_layout Standard
Partial updates from Property Sets should also be possible
\end_layout

\begin_layout LyX-Code
COPY PROPERTIES a,b,c FROM machine_a TO machine_b;
\end_layout

\begin_layout Subsubsection
Dynamic values
\end_layout

\begin_layout Standard
Some expressions include a calculation that needs to be reevaluated each
 time the expression is evaluated, these are calculations, for example of
 the size of a list, the class of a machine, the number of items on a list
 that are in a given state.
 These `dynamic values' are:
\end_layout

\begin_layout Itemize
ANY IN
\end_layout

\begin_layout Itemize
ALL IN
\end_layout

\begin_layout Itemize
COUNT ..
 FROM ..
\end_layout

\begin_layout Itemize
SIZE OF
\end_layout

\begin_layout Itemize
INCLUDES
\end_layout

\begin_layout Itemize
ITEM AT
\end_layout

\begin_layout Itemize
BITSET FROM
\end_layout

\begin_layout Itemize
ENABLED
\end_layout

\begin_layout Itemize
DISABLED
\end_layout

\begin_layout Itemize
EXISTS
\end_layout

\begin_layout Itemize
CLASS OF
\end_layout

\begin_layout Itemize
SUM OF list [ not implemented yet]
\end_layout

\begin_layout Itemize
VALUE OF symbol [when is this needed]
\end_layout

\begin_layout Subsubsection
Automatic properties
\end_layout

\begin_layout Standard
Properties can be defined to be equivalent to the result of a calculation
 by using the LET command:
\end_layout

\begin_layout LyX-Code
LET property_name BE expression;
\end_layout

\begin_layout Standard
When defind this way, the expression will be evaluated when necessary, for
 example when one of its members changes.
 The guarantee applies (at least initially) only for state calculations
 and upon entry to a command or state-change method.
 Automatic properties are private.
\end_layout

\begin_layout Subsubsection
Conditional Assignment
\end_layout

\begin_layout Standard
The conditional assignment operator provides a way to make an assignment
 based on evaluation of conditions.
 A synopsis is:
\end_layout

\begin_layout LyX-Code
property =: expression1 WHEN condition1 =: expression2 WHEN condition2 ...
 [ expressionN OTHERWISE]
\end_layout

\begin_layout Standard
the first assignments is made based on the first condition to evaluate to
 true when evaluated in the order written.
 This is equivalent to:
\end_layout

\begin_layout LyX-Code
IF condition1 property := expression1
\end_layout

\begin_layout LyX-Code
ELSIF condition2 property := expression2
\end_layout

\begin_layout LyX-Code
...
\end_layout

\begin_layout LyX-Code
[ELSE property := expressionN]
\end_layout

\begin_layout Subsubsection
Invariants
\end_layout

\begin_layout Standard
Methods can contain declarations of invariant conditions.
 If an invariant is evaluated as false the program cannot continue to run
 and will enter its failsafe mode
\end_layout

\begin_layout Subsubsection
Strict
\end_layout

\begin_layout Standard
When applied to a machine, STRICT causes the machine to refuse to change
 the type of a property once set and causes a system exit if a machine is
 asked to transition to an unknown state.
 
\end_layout

\begin_layout Subsubsection
Failsafe Mode
\end_layout

\begin_layout Standard
A program may be configured with a failsafe mode that includes a set of
 states and properties that can be activated whenever the program detects
 a non-recoverable error.
 Failsafe mode can be activated by:
\end_layout

\begin_layout Itemize
throwing an exception that nothing catches,
\end_layout

\begin_layout Itemize
causing an invariant to evaluate to false
\end_layout

\begin_layout Itemize
executing a FAIL statement.
\end_layout

\begin_layout Standard
The syntax for this feature has not been decided yet.
\end_layout

\begin_layout Subsubsection
Data Sources
\end_layout

\begin_layout Standard
Data sources are objects that provide data, either on a polled or automatic
 basis.
\end_layout

\begin_layout LyX-Code
my_data DATASOURCE {
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout LyX-Code
COMMANDS { 
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout LyX-Code
CONNECT, # connect to the external source
\end_layout

\begin_layout LyX-Code
DISCONNECT, # disconnect from the external source
\end_layout

\begin_layout LyX-Code
NEXT # attempt to get a record from the external source and update linked
 properties
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
}
\end_layout

\end_deeper
\begin_layout Standard
They can be linked to a property set:
\end_layout

\begin_layout LyX-Code
LINK my_data TO my_properties;
\end_layout

\begin_layout LyX-Code
LINK my_properties TO my_machine, ...;
\end_layout

\begin_layout Subsection
Functions
\end_layout

\begin_layout Standard
Actions are executed when a message is received by a machine.
 These actions may return a result that can be used in a property assignment.
\end_layout

\begin_layout Standard
Steps within a function are executed until a step cannot be resolved immediately
, for example, when a SET statement is used to set the state of another
 machine.
 The SET does not complete until the other machine has changed state.
 In the current implementation, the other machine may have only started
 to invoke its ENTER function (TBD).
\end_layout

\begin_layout Standard
Steps may be artifically stopped by using the YIELD statement and in the
 future functions may be interrupted because of the use of a regular I/O
 poll.
 
\end_layout

\begin_layout Standard
It should be assumed that there is no guarantee that non-blocking steps
 of a method are always executed at once but this happens to be a property
 of the current implementation.
\end_layout

\begin_layout Standard
A function may be invoked by a CALL statement in which case the calling
 machine blocks until the function is complete.
 On completion, a result property 'RESULT' will contain the result of the
 function.
 RESULT is actually a REFERENCE (see section 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:References"

\end_inset

) so it can return multiple properties and a reference to a machine.
 For example:
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
CALL method ON machine;
\end_layout

\begin_layout LyX-Code
property := RESULT.val;
\end_layout

\begin_layout LyX-Code
SEND go TO RESULT.ITEM;
\end_layout

\begin_layout Subsection
References
\begin_inset CommandInset label
LatexCommand label
name "subsec:References"

\end_inset


\end_layout

\begin_layout Standard
The reference type REFERENCE is provided to provide a way to make a reference
 to another object.
 It has operations to assign and to clear the reference and has two states:
 EMPTY and ASSIGNED.
 Once an object is assigned to a reference, the object can be obtained using
 reference.ITEM.
 Referring to the ITEM on an empty reference produces undefined behaviour.
\end_layout

\begin_layout Standard
The implementation of a reference is similar to 
\end_layout

\begin_layout LyX-Code
REFERENCE MACHINE {
\end_layout

\begin_layout LyX-Code
    ITEM ANY_MACHINE;
\end_layout

\begin_layout LyX-Code
    ASSIGNED WHEN ITEM != NULL;
\end_layout

\begin_layout LyX-Code
    EMPTY DEFAULT;
\end_layout

\begin_layout LyX-Code
    
\end_layout

\begin_layout LyX-Code
    COMMAND clear { } # clear the current ITEM 
\end_layout

\begin_layout LyX-Code
    COMMAND assign WITH new_item {  } # clear the current item then set
 it to new_item
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
Calling clear on the reference will unassign the object that was previously
 assigned and calling assign will perform an assignment.
 
\end_layout

\begin_layout Standard
Note: Initially, the language does not provide a way to return an object
 from a function.
\end_layout

\begin_layout Subsection
Streams
\end_layout

\begin_layout Standard
A Stream is an ordered collection of data that can be grouped into fixed
 size units (bits, bytes, chars etc); it has a current value and position.
 the position can be moved forward or backward and the value can be read
 and changed.
 Streams may have a beginning and end and has a state of closed, valid or
 invalid.
 In the closed and invalid state, the current value cannot be read; if the
 stream is moved past the end or before its beginning, it becomes invalid.
 A Reader is a special case of a Stream in which the data cannot be changed,
 similarly, a Writer is a Stream that can only be written to.
\end_layout

\begin_layout LyX-Code
s READER 
\begin_inset Quotes eld
\end_inset

example.dat
\begin_inset Quotes erd
\end_inset

:1; # read one bit at a time
\end_layout

\begin_layout LyX-Code
done WHEN s IS invalid; # terminating condition
\end_layout

\begin_layout LyX-Code
start WHEN s IS closed;
\end_layout

\begin_layout LyX-Code
one WHEN s.curr == 1;
\end_layout

\begin_layout LyX-Code
zero WHEN s.curr == 0;
\end_layout

\begin_layout LyX-Code
ENTER start { SEND open TO s }
\end_layout

\begin_layout LyX-Code
ENTER one { LOG 
\begin_inset Quotes eld
\end_inset

1
\begin_inset Quotes erd
\end_inset

; SEND forward TO s }
\end_layout

\begin_layout LyX-Code
ENTER zero { LOG 
\begin_inset Quotes eld
\end_inset

0
\begin_inset Quotes erd
\end_inset

; SEND forward TO s }
\end_layout

\begin_layout Subsection
Data
\end_layout

\begin_layout Standard
Machines currently have an unstructured set of properties as the only method
 of handling data.
 In the short term this won't change but we are starting to add some tools
 to help manupulate data.
 For example
\end_layout

\begin_layout LyX-Code
COPY PROPERTIES FROM machine1 TO machine2
\end_layout

\begin_layout LyX-Code
COPY PROPERTIES property_name,...
 FROM machine1 TO machine2
\end_layout

\begin_layout Standard
Note that this statement does not copy the reserved properties NAME and
 STATE, other pseudo-properties like TIMER or properties marked as LOCAL.
\end_layout

\begin_layout Standard
It is convenient to be able to save and restore the state of an entire list
 of objects.
 One mechanism to support this is the bit functions; a list of objects can
 be packed into a bitmap, represented in the language by a property value.
 For example, a LIST may contain a list of FLAG machines, each of which
 have a state of on or off.
 This list can be mapped to a an array of bits where each bit records the
 state of a machine.
 In theory, a list can be of arbitrary length and so can a BITMAP, in practice,
 we expect that many algorithms only need a small list and so such a list
 may be able to be packed into a single integer property value.
 BITSET values are packed structures that can pack lists with a limited
 number of items (currently 32) [and possibly with the advantage that the
 items of a bitset are still addressible].
\end_layout

\begin_layout Standard
Further, a BITSET can be generated from properties as well as states in
 either case, a notation is required that provides a way to describe the
 way that bitsets are packed.
 
\end_layout

\begin_layout Standard
The state of list entries can be converted to a bitset and back using statements
 like the following
\end_layout

\begin_layout LyX-Code
my_flags := BITSET FROM ENTRIES OF list WITH STATES off,on
\end_layout

\begin_layout LyX-Code
SET ENTRIES OF list FROM BITSET my_flags WITH STATES [on=1,off=0]
\end_layout

\begin_layout Standard
Equivalent forms exist that can map a set or properties rather than states
\end_layout

\begin_layout LyX-Code
val := BITSET FROM ENTRIES OF list WITH PROPERTY a;
\end_layout

\begin_layout LyX-Code
SET PROPERTIES OF ENTRIES OF list FROM BITSET val WITH PROPERTY [a:1];
\end_layout

\begin_layout Standard
Both the state and property forms of these statements can be abbreviated
 by removal of the 'ENTRIES OF' clauses:
\end_layout

\begin_layout LyX-Code
my_flags := BITSET FROM list WITH STATES off,on
\end_layout

\begin_layout LyX-Code
SET list FROM BITSET my_flags WITH STATES [on=1,off=0]
\end_layout

\begin_layout Standard
In both cases, the WITH STATES clauses can also be removed if the specification
 is using a list of flags or a list of integers:
\end_layout

\begin_layout LyX-Code
my_flags := BITSET FROM list;
\end_layout

\begin_layout LyX-Code
SET list FROM BITSET my_flags;
\end_layout

\begin_layout Subsubsection
Bit packing notation
\end_layout

\begin_layout Standard
The programmer can control how states or properties are mapped into a bitmap;
 a subset of states may be used and multiple bits per state or property
 may also be used.
 The notation is
\end_layout

\begin_layout LyX-Code
specification = specifier | '[' specifier [ ',' specifier ] ']'
\end_layout

\begin_layout LyX-Code
specifier = name [ '=' value ] [ ':' size ]
\end_layout

\begin_layout Standard
The size indicate sets the number of bits to be used for each value, if
 it is not given, the size will be the smallest number of bits needs to
 hold the largest value in the specification.
 The name is the name of the state or the name of the property, depending
 on the statement in which the specification is being used.
 The value is a non-negative integer (0,1,2,..) giving the bit pattern to
 be used to represent each state.
 Note that in this specification, there is currently no way to nominate
 whether a big-endian or little endian packing of the values.
\end_layout

\begin_layout Standard
For example, 
\end_layout

\begin_layout Description
on=1,off=0 indicates that state or property 'on' will be represented by
 one and state or property 'off' will be represented by zero.
 
\end_layout

\begin_layout Description
off,on has the same effect; since no value is given, it defaults to 0, 1
 etc and all states or properties not represented in the list map to zero
\end_layout

\begin_layout Description
on=1:1,off=0:1 is the complete specification, avoiding the use of defaults
\end_layout

\begin_layout Subsubsection
Persistence
\end_layout

\begin_layout Standard
Currently persistencs is a hack using a property `PERSISTENT' that causes
 a machine to announce statue or property changes on a persitence channel
 whenever a change occurs.
 This is to be upgraded to become a feature of the language and the following
 clauses will be added:
\end_layout

\begin_layout Description
PERSISTENT means that the machine is persistent and all properties within
 the machine are saved in the persistent store if enabled at runtime.
 For backward compatibility the PERSISTENT property is still supported for
 this purpose.
\end_layout

\begin_layout Description
VOLATILE means that the given property is not included in the persistent
 properties of a machine so these values are not written to the persistence
 store
\end_layout

\begin_layout Description
PRIVATE means that the named option is not visible outside of the machine
 (even to sub-machines) and it is not published on any channel unless the
 channel includes a specific option to include private objects (persistence,
 samplers and debuggers may include private properties for example)
\end_layout

\begin_layout Description
LOCAL means that the named option is not published on any channel unless
 the channel includes a specific option to include local properties.
 Local properties are still accessible to other machines.
\end_layout

\begin_layout Subsection
Lists
\end_layout

\begin_layout Standard
Procedural or functional style? A functional language tends to use functions
 such as car and cdr.
 Similar to sets, it should be possible to enumerate objects and also to
 receive events as items are added or removed from the list.
\end_layout

\begin_layout Subsection
Data hiding
\end_layout

\begin_layout Standard
Add: check PRIVATE STATE WITHIN visible_alias or perhaps just PRIVATE STATE
 that simply doesn't update the external view of what state the machine
 is in.
 Considr perhaps SHOW state_name FOR state_name.
\end_layout

\begin_layout Subsection
Type checking
\end_layout

\begin_layout Standard
Consider adding: sample MACHINE p1 class1, p2 class2
\end_layout

\begin_layout Subsection
Substates
\end_layout

\begin_layout Subsection
Exceptions
\end_layout

\begin_layout Standard
Exceptions are messages that are broadcast to several receivers, based on
 whether they CATCH the event or not.
 An exception is sent by the THROW command and this command causes a handler
 to abort at point the exception is sent.
 I would like to consider the option of temporarily listening for events,
 including exceptions and this is likely to be done via a LISTEN command
 to enable listening and an IGNORE command to disable listening.
 By default, if a machine implements an event handler for an event it is
 assumed to be listening for the event.
 
\end_layout

\begin_layout Subsection
Conditions
\end_layout

\begin_layout Standard
Conditions are not currently implemented but they are intended to operate
 as shortcuts or optimisations that reduce the need to have a large set
 of expressions on WHEN clauses.
 Effectively, a CONDITION is a machine that is true when the expression
 is true and false otherwise.
\end_layout

\begin_layout Subsection
Error handling
\end_layout

\begin_layout Standard
Clockwork 1.0 introduces exception and error handling
\end_layout

\begin_layout LyX-Code
TRY {
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout LyX-Code
statement-list
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
WHEN TIMER >= timeout {
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout LyX-Code
ABORT; # unsuccessful completion
\end_layout

\begin_layout LyX-Code
RETURN; # successful completion 
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
CATCH message {
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout LyX-Code
LOG 
\begin_inset Quotes eld
\end_inset

Error: 
\begin_inset Quotes eld
\end_inset

 + message + 
\begin_inset Quotes eld
\end_inset

 detected
\begin_inset Quotes erd
\end_inset


\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
In addition, certain statements add ON ERROR and ON TIMEOUT clauses that
 can be used separately ot together.
\end_layout

\begin_layout LyX-Code
SET machine TO state ON ERROR { ...
 }
\end_layout

\begin_layout LyX-Code
CALL handler ON machine ON ERROR { ...
 }
\end_layout

\begin_layout LyX-Code
SET machine TO state ON TIMEOUT n { ...
 }
\end_layout

\begin_layout LyX-Code
CALL handler ON machine ON TIMEOUT n { ...
 }
\end_layout

\begin_layout Standard
Errors may be generic, as above, where the one error handler will handle
 all errors from the statement or my be specific where the error is generated
 with the handler and caught in the ON ERROR.
 In the following example, the handler may return different application
 specific errors and the CALL of the handler can deal with each error with
 a specific block.
\end_layout

\begin_layout LyX-Code
COMMAND handler { IF ...
 ERROR error1; ...
 ELSE...
 ERROR error2; ...
 }
\end_layout

\begin_layout LyX-Code
CALL handler ON machine ON ERROR error1 { ....
 } ON ERROR error2 { ...
 }
\end_layout

\begin_layout Standard
If necessary a handler can THROW a message and another part of the machine
 can CATCH it
\end_layout

\begin_layout LyX-Code
COMMAND handler { ...; THROW error_name; ...
 }
\end_layout

\begin_layout LyX-Code
...
\end_layout

\begin_layout LyX-Code
CATCH error_name { ...
 }
\end_layout

\begin_layout Standard
Rather than having a single CATCH within the machine, an error handler may
 be specified on the CALL:
\end_layout

\begin_layout LyX-Code
CALL handler ON machine ON error1 {...} ON error2 {...}
\end_layout

\begin_layout LyX-Code
COMMAND handler { ...
 THROW error1; ...
 }
\end_layout

\begin_layout Standard
Note that statements after a THROW are not executed and the handler is deemed
 to have failed.
 An ON ERROR will catch a THROWn error but it will also be caught by matching
 CATCHers.
 The special name ALL can be used with a CATCH to catch every THROWn message:
\end_layout

\begin_layout LyX-Code
CATCH ALL { num_errors := num_errors + 1 }
\end_layout

\begin_layout Subsection
State changes
\end_layout

\begin_layout Standard
We have clarified what is meant by 
\begin_inset Quotes eld
\end_inset

machine IS state
\begin_inset Quotes erd
\end_inset

 to mean that the conditions for that state are true and the machine has
 completed the transition to the state.
 Once a machine has started to change state, it enters a private 
\begin_inset Quotes eld
\end_inset

leaving
\begin_inset Quotes erd
\end_inset

 state for the previous state and then a private 
\begin_inset Quotes eld
\end_inset

entering
\begin_inset Quotes erd
\end_inset

 state for the new state before finally becoming on.
 Since they are private states, the machine will appear to the outside world
 to still be in the original state.
\end_layout

\begin_layout Standard
Two new verbs are added: LEAVING and ENTERING, these can be used to get
 access to the private parts of the transition.
\end_layout

\begin_layout Standard
Is a transitional state equal to a normal state with the same name?
\end_layout

\begin_layout Standard
is a private state equal to a normal state with the same name?
\end_layout

\begin_layout Standard
PRIVATE states can be used to simplify the external interface of a machine.
\end_layout

\begin_layout LyX-Code
turning_on PRIVATE STATE;
\end_layout

\begin_layout LyX-Code
on STATE;
\end_layout

\begin_layout LyX-Code
PRIVATE STATES a,b,c;
\end_layout

\begin_layout Standard
To indicate that a stable state is private the state needs to be declared
 as a PRIVATE STATE as well as being defined in a WHEN clause in the normal
 way.
\end_layout

\begin_layout Standard
Consider simply setting 'transitional' on a state during the enter/leave
 process.
\end_layout

\begin_layout Standard
Consider adding a new test to see if a machine is currently transitioning:
 wait WHEN other IS CHANGING STATE;
\end_layout

\begin_layout Standard
As part of this cleanup, some work needs to be done on the current implementatio
n of USING.
 At present, given
\end_layout

\begin_layout Standard
TRANSITION a TO b USING next;
\end_layout

\begin_layout Standard
will provide a command called 'next' that causes a transition from 'a' to
 'b'.
 This will also cause an effect whereby if the machine moves from 'a' to
 'b' by a direct 'SET', the next command will still be executed.
 A new verb is required to specifically enable this behaviour:
\end_layout

\begin_layout Standard
TRANSITION a TO b USING next; # retains the legacy behaviour
\end_layout

\begin_layout Standard
TRANSITION a TO b AFTER next; # the 'next' command causes the transition
 once it completes
\end_layout

\begin_layout Standard
TRANSITION a TO b INVOKES starting; # the 'starting' handler is invoked
 after the machine transitions from a to b
\end_layout

\begin_layout Standard
The two clauses can be combined.
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Subsection
Support of parallel execution
\end_layout

\begin_layout Standard
The most direct method to support parallel execution is to identify separate
 chains of dependency within the machine graph.
 Thus, for example, changes that occur in one input may be able to be completely
 processed in parallel with another chain if the steps are independent of
 changes that occur in another input.
 [yuk reword]
\end_layout

\begin_layout Standard
More explanation required
\end_layout

\begin_layout Subsection
Type Extensions
\end_layout

\begin_layout Standard
Type extensions provide for adding parameters, statements to the handlers
 within a state machine, fields and substates.
\end_layout

\begin_layout LyX-Code
A MACHINE { \SpecialChar ldots
 };
\end_layout

\begin_layout LyX-Code
B MACHINE EXTENDS A <additional parameters> {
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout LyX-Code
<event handler extensions>
\end_layout

\begin_layout LyX-Code
<additional fields>
\end_layout

\begin_layout LyX-Code
<state extensions>
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
More thought is required here, what I am planning is that clauses within
 B can be defined as separate or as extensions of those in A, for example
 INIT { ...
 } simply defines a handler for the INIT state in B.
 Whereas INIT EXTENDS A.INIT { ...
 } defines extra steps that are added to the handler already defined in
 A.
\end_layout

\begin_layout Standard
When a MACHINE is extended, all instances of the object share default properties
 of the extended type unless they are explicitly added for the derived machine.
\end_layout

\begin_layout Subsection
Protocols
\end_layout

\begin_layout Standard
Protocols can be used to ensure that machines passed as parameters actually
 provide the correct facilities.
 A machine can conform to multiple protocols.
\end_layout

\begin_layout LyX-Code
switch PROTOCOL { STATES { on, off; } COMMANDS {turnOn, turnOff} }
\end_layout

\begin_layout LyX-Code
controller MACHINE on_off<switch> { ...
 }
\end_layout

\begin_layout Standard
In the above, the machine passed to the controller will be required to have
 only a state 'on' and a state 'off' and support the turnOn and turnOff
 commands.
\end_layout

\begin_layout Standard
If the switch is to be also allowed to have other states or commands we
 would describe it:
\end_layout

\begin_layout LyX-Code
switch PROTOCOL { STATES { on, off, ...; } COMMANDS {turnOn, turnOff, ...} }
\end_layout

\begin_layout Standard
TBD
\end_layout

\begin_layout Subsection
Data access
\end_layout

\begin_layout Standard
Data is often modified during a process but it is not appropriate for external
 monitors to see data until it is in a stable state.
 The intention is to add a facility that can be used to perform data calculation
s using internal, private instances and to only make the data available
 externally in certain states.
 See LOCAL, PRIVATE.
\end_layout

\begin_layout Subsection
Date and Time functions
\end_layout

\begin_layout Standard
Note that these properties cannot be used in WHEN clauses of automatic states
 since they do not generate events as they change.
\end_layout

\begin_layout Description
NOW the current time in milliseconds
\end_layout

\begin_layout Description
DAY the number of the current day (1..31)
\end_layout

\begin_layout Description
MONTH the number of the current month (1..12)
\end_layout

\begin_layout Description
YR the current year (two digits)
\end_layout

\begin_layout Description
YEAR the curren tyear (four digits)
\end_layout

\begin_layout Description
HOUR the current hour (0..23)
\end_layout

\begin_layout Description
MIN the current minute within the hour (0..59)
\end_layout

\begin_layout Description
SEC the current second within the current minute (0..59)
\end_layout

\begin_layout Standard
Retriggering of subcondition; syntax:
\end_layout

\begin_layout LyX-Code
state WHEN condition,
\end_layout

\begin_layout LyX-Code
EXECUTE method WHENEVER condition, 
\end_layout

\begin_layout LyX-Code
TAG machine WHENEVER condition,
\end_layout

\begin_layout LyX-Code
EXECUTE (DO) method EVERY duration;
\end_layout

\begin_layout Subsection
Frequency Calculation
\end_layout

\begin_layout Standard
All single bit inputs have the option of having their cycle frequency calculated.
 The simplest method for this is to record the number of cycles of the input
 state over a period of time.
 There is no need to perform the calculation of 
\begin_inset Formula $\frac{cycle}{time}$
\end_inset

 until the frequency data is actually needed.
 A clever algorithm will be used to ensure that the counter and time period
 values use sensible ranges (eg per sec, per msec etc).
\end_layout

\begin_layout Standard
Initially no attempt will be made to identify input frequency for analogue
 inputs.
\end_layout

\begin_layout Subsection
Priorities
\end_layout

\begin_layout Standard
A machine will be able to be given a priority or a polling rate to indicate
 that events for this machine are to be handled more or less frequently
 than other machines
\end_layout

\begin_layout Subsection
Cycle Time
\end_layout

\begin_layout Standard
The program must be able to be configured to use a faster or slower cycle
 time in order to save power on small devices and to give better performance
 when dealing with demanding tasks.
\end_layout

\begin_layout Subsection
Input polling
\end_layout

\begin_layout Standard
Currently the machine follows a cycle that is input-process-output on a
 fixed clock.
 The new design pushes work to be done onto a processing queue and that
 processing queue operates until the cycle time arrives and then performs
 a read/update cycle to the IO.
 
\end_layout

\begin_layout Standard
This approach must buffer incoming data in order to prevent invalid state
 processing on machine with automatic states.
 This will be done by marking some tasks as high priority such that these
 tasks but be performed every cycle.
 Further thought is required.
\end_layout

\begin_layout Subsubsection
Command Polling
\end_layout

\begin_layout Standard
A subcondition can be used to repeat an action only while a machine is in
 a particular state:
\end_layout

\begin_layout Standard
EXECUTE / DO command EVERY time_period;
\end_layout

\begin_layout Subsection
Property calculations
\end_layout

\begin_layout Standard
OPTION x expession
\end_layout

\begin_layout Subsection
Dynamic machines
\end_layout

\begin_layout Standard
New machines can be constructed with the CREATE command and removed with
 the DESTROY command.
 An object cannot be destroyed if it is being used within another object
 (ie it has dependencies) or is passed to another object, it needs to be
 either removed from that object or that object must first be destroyed.
 Automatic reference counting is used so that when objects leave scope they
 are automatically destroyed.
\end_layout

\begin_layout Standard
Objects that are allocated statically can never be destroyed and reference
 counting is not necessary for these items (it may still be applied, however..TBD)
\end_layout

\begin_layout Subsection
Linked states
\end_layout

\begin_layout Standard
States in cooperating machines can be linked to ensure that one machine
 passes through a gateway state before another machine may pass through
 a linked state.
\end_layout

\begin_layout Subsection
Patterns
\end_layout

\begin_layout Standard
Access parts of a pattern via COPY pattern FROM source TO list
\end_layout

\begin_layout Subsection
Extensions
\end_layout

\begin_layout Standard
New machine types can be defined by loadable modules.
 A loadable module is required to provide a particular interface that is
 used when instances of objects from that module are processed.
 It may be possible to provide loadable objects using a messaging or rpc
 interface.
 (TBD)
\end_layout

\begin_layout Subsubsection
The EtherCAT extension
\end_layout

\begin_layout Standard
This extension provides an object of type EtherCAT_Entry when instantiated,
 this machine registers a pdo entry with ethercat, using the details provided.
 The extension also adds an SDO object for performing SDO functions.
 Note that currently this is hard-coded into the interpreter.
 
\end_layout

\begin_layout Subsubsection*
Using SDO within Clockwork
\end_layout

\begin_layout Standard
To add an SDO entry, add an instance of a machine with class SDOENTRY in
 the clockwork configuration.
 The parameters of an SDOENTRY are:
\end_layout

\begin_layout Description
module the clockwork name for the EtherCAT module that the entry is in
\end_layout

\begin_layout Description
index the index value of the entry
\end_layout

\begin_layout Description
subindex the subindex value of the entry
\end_layout

\begin_layout Description
size the size (in bytes) of the entry (TBD fix this and implement support
 for single bit SDO entries)
\end_layout

\begin_layout Standard
The object has a VALUE property that can be set and read within the code
 and an IOTIME that indicates the last time the entry was read from the
 io hardware.
 A `defautl' property can also be set to indicate that this entry is to
 be initialised before the control logic is given access to the hardware.
\end_layout

\begin_layout Subsection
Type Extensions
\end_layout

\begin_layout Standard
Machines should be able to be defined as extensions of existing machines.
 Initially these extensions will only be able to add actions and commands.
 Some thought will be needed as to whether actions will be executed before
 or after existing actions.
 
\end_layout

\begin_layout Subsection
Introspection
\end_layout

\begin_layout Standard
Clockwork already has facilities to enable and disable parts of the executing
 machine.
 To make it easier to address groups of machines some facilities will be
 added tselect machines within the current instance:
\end_layout

\begin_layout LyX-Code
points LIST FROM SELECT MACHINES OF TYPE POINT;
\end_layout

\begin_layout LyX-Code
outputs LIST FROM SELECT MACHINES WITH NAME MATCHING `^O_`;
\end_layout

\begin_layout Standard
or 
\end_layout

\begin_layout LyX-Code
points LIST;
\end_layout

\begin_layout LyX-Code
SELECT MACHINES OF TYPE POINT INTO points;
\end_layout

\begin_layout Subsection
Macros
\end_layout

\begin_layout Standard
Macros replace a tagged section of the program with a user-defined scrap
 of text, optionally substituting text in the process.
 All characters are copied literally, including line breaks, spaced and
 tab characters.
 [TBD should we instead trim leading and trailing whitespace and include
 a single space between entries when updating a macro definition?]
\end_layout

\begin_layout Standard
A macro has the form:
\end_layout

\begin_layout LyX-Code
DEFINE name [ '(' name1 [ ',' name1 ]...
 ')' ] '{' text '}'
\end_layout

\begin_layout Standard
Within the text, name1, name2 etc are replaced with the values provided
 where the macro is to be expanded.
\end_layout

\begin_layout Standard
To introduce a macro use:
\end_layout

\begin_layout LyX-Code
DEFINE sum(a,b) { a + b }
\end_layout

\begin_layout Standard
To expand the macro, use the name and parameters part of the above:
\end_layout

\begin_layout LyX-Code
three := sum(1,2);
\end_layout

\begin_layout Standard
A macro name may include spaces and if desired, the expansion may include
 expansion markers '@<' and '@>' to make it clear that a macro is being
 used.
 For example:
\end_layout

\begin_layout LyX-Code
DEFINE initialise the variables { x := 0; }
\end_layout

\begin_layout LyX-Code
...
\end_layout

\begin_layout LyX-Code
ENTER INIT { @<initialise the variables@> }
\end_layout

\begin_layout Standard
Note that it is perfectly fine to write the following
\end_layout

\begin_layout LyX-Code
DEFINE initialise the variables { x := 0; }
\end_layout

\begin_layout LyX-Code
...
\end_layout

\begin_layout LyX-Code
ENTER INIT { initialise the variables }
\end_layout

\begin_layout Standard
Unlike other macro systems, in clockwork a macro can be reintroduced and
 this simply adds the extra text to the macro expansion.
 All macros are collected throughout the source before expansion begins
 so this feature can be used to reorder the program to suit the reader if
 desired.
 For example, the above example might have been:
\end_layout

\begin_layout LyX-Code
DEFINE initialise the variables { x := 0; }
\end_layout

\begin_layout LyX-Code
...
\end_layout

\begin_layout LyX-Code
DEFINE initialise the variables { y := 0; }
\end_layout

\begin_layout LyX-Code
...
\end_layout

\begin_layout LyX-Code
ENTER INIT { @<initialise the variables@> }
\end_layout

\begin_layout Standard
In which case, the INIT method would have expanded to
\end_layout

\begin_layout LyX-Code
ENTER INIT { x:=0;  y:=0; }
\end_layout

\begin_layout LyX-Code

\end_layout

\end_body
\end_document
