#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\topmargin 1cm
\rightmargin 2cm
\bottommargin 2cm
\headheight 1cm
\headsep 1cm
\footskip 1cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Clockwork Language Reference (draft)
\end_layout

\begin_layout Author
Martin Leadbeater
\end_layout

\begin_layout Section
Preface
\end_layout

\begin_layout Standard
Please note that this is 
\emph on
still
\emph default
 a very early draft.
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
Clockwork is a language intended to be used to describe systems of interacting
 components using state machines.
 The purpose of the language is to provide a platform for monitoring and
 control and it has currently been implemented as a control system using
 Beckhoff EtherCATÂ® and The Internet of Things (MQTT).
\end_layout

\begin_layout Standard
The language provides the programmer with a means to:
\end_layout

\begin_layout Itemize
define the states of a machine in terms of conditions
\end_layout

\begin_layout Itemize
define commands that can be invoked on the machine
\end_layout

\begin_layout Itemize
define transition rules that determine what actions can be performed and
 what state transtions are allowable
\end_layout

\begin_layout Itemize
define state entry functions that execute when a machine enters a state
\end_layout

\begin_layout Itemize
monitor the operation of a machine by sampling events as they occur and
 interactively inspecting the state and properties of internal components
\end_layout

\begin_layout Itemize
view the state and properties of the machine in a web browser
\end_layout

\begin_layout Itemize
view the operation of a machine in a 3D view
\end_layout

\begin_layout Itemize
interface to serial devices, network devices and modbus devices
\end_layout

\begin_layout Itemize
program embedded devices and microcontrollers (not yet available)
\end_layout

\begin_layout Subsection
Machines
\end_layout

\begin_layout Standard
The main components in a Clockwork program are called Machines.
 Machines are models of processing components or real-world devices that
 can be interconnected.
 Each Machine has a current state and (normally) several other states that
 the machine may automatically move to or that can be manually set by processing
 steps in the program.
\end_layout

\begin_layout Standard
The key difference between Clockwork and other state machine systems is
 that in Clockwork the software components automatically move between states
 by monitoring a set of conditions that define the states.
 As with other systems, it is also possible to define transition tables
 that describe how a system moves between states based on events.
 Conditions on a machine are defined in terms of the state and properties
 of itself and other machines, Machines continuously evaluate these conditions
 and automatically switch to the first state found that matches the condition,
 executing its state entry function as it does so.
 When a state includes a condition, we tend to refer to that as a 
\emph on
stable 
\emph default
state but these could also be called 
\emph on
automatic
\emph default
 states.
\end_layout

\begin_layout Standard
Each type of machine is defined by a block of code that provides the name,
 parameters, properties, conditions and processing of the machine.
 For example, here is a definition for a Machine that behaves like an and
 gate in an electronic circuit.
 
\end_layout

\begin_layout LyX-Code
AndGate MACHINE input1, input2
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_deeper
\begin_layout LyX-Code
on WHEN input1 IS on AND input2 IS on;
\end_layout

\begin_layout LyX-Code
off DEFAULT
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
The machine definition for this AndGate requires two parameters for the
 two inputs and defines a condition on state `on' that will activate when
 both inputs are on.
 The statement 
\noun on
'
\family typewriter
\noun default
off DEFAULT
\family default
\noun on
'
\noun default
 defines a default condition on the 
\family typewriter
off
\family default
 state that always returns true.
 There can be only one DEFAULT state in each machine but it is not required;
 the presence of a default state ensures that machines of this type will
 be in the on state when the condition is true and only when the condition
 is true.
\end_layout

\begin_layout Standard
A machine definition can be instantiated by providing a name, the name of
 the machine definition, also called the machine `class', and a list or
 parameters that are required by the definition.
 For example, following is a machine that monitors two inputs and turns
 on when both inputs are on:
\end_layout

\begin_layout LyX-Code
and_gate AndGate a, b;
\end_layout

\begin_layout LyX-Code
a FLAG;
\end_layout

\begin_layout LyX-Code
b FLAG;
\end_layout

\begin_layout Standard
Note that the FLAG machine type is defined internally in the language but
 it is equivalent to a machine defined like this:
\end_layout

\begin_layout LyX-Code
FLAG MACHINE
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_deeper
\begin_layout LyX-Code
on STATE;
\end_layout

\begin_layout LyX-Code
off INITIAL;
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
Thus a FLAG can be either on or off and is initially off.
 There are no rules to define how the machine might automatically move between
 those states so it is left to other parts of the program to change the
 state of the FLAG as required.
\end_layout

\begin_layout Subsection
Controlling outputs
\end_layout

\begin_layout Standard
The above AndGate machine does not directly control any other part of the
 system, it simply sets its own state based on its inputs.
 After detecting the condition where both of the inputs are on, we may want
 to do something about it.
 The AndGate can be adjusted to, for example, turn on a light when the two
 inputs are on, to do this, we add an ENTER method for the on state:
\end_layout

\begin_layout LyX-Code
AndGateSwitch MACHINE input1, input2, output
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_deeper
\begin_layout LyX-Code
on WHEN input1 IS on AND input2 IS on;
\end_layout

\begin_layout LyX-Code
off DEFAULT;
\end_layout

\begin_layout LyX-Code
ENTER on { SET output TO on; }
\end_layout

\begin_layout LyX-Code
ENTER off { SET output TO off; }
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
light FLAG;
\end_layout

\begin_layout LyX-Code
a FLAG;
\end_layout

\begin_layout LyX-Code
b FLAG;
\end_layout

\begin_layout LyX-Code
and_gate AndGateSwitch a, b, light;
\end_layout

\begin_layout Standard
This approach, where we pass the object to be controlled makes the linkage
 explicit but there is alternative, where another machine monitors the state
 of the AndGate and then performs the control function:
\end_layout

\begin_layout LyX-Code
LightController MACHINE input, output {
\end_layout

\begin_deeper
\begin_layout LyX-Code
  active WHEN 1==1, TAG output WHEN input IS on;
\begin_inset Foot
status open

\begin_layout Plain Layout
Note the test 1==1 is a functional placeholder; the intention is to define
 the value TRUE for this kind of situation.
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
light FLAG;
\end_layout

\begin_layout LyX-Code
a FLAG; b FLAG;
\end_layout

\begin_layout LyX-Code
and_gate AndGate a, b;
\end_layout

\begin_layout LyX-Code
lc LightController and_gate, light
\end_layout

\begin_layout Standard
in this case, AndGate does not manipulate or even know about the output.
\end_layout

\begin_layout Standard
It is not clear yet whether this approach is better or worse in general
 however, if multiple machines need to be driven by the AndGate, the separate
 controller pattern is much more reusable.
\end_layout

\begin_layout Standard
So far we have been using FLAG machines as placeholders for machines that
 have an interface to hardware.
 For the sake of describing the language, this is sufficient and has the
 advantage that a command interface or web page can be used to alter the
 flags for test purposes.
 Please refer to the user manual for information about the command interface
 and the web interface.
\end_layout

\begin_layout Subsection
Parts of a machine
\end_layout

\begin_layout Standard
The definition of a machine includes several sections:
\end_layout

\begin_layout Itemize
declaration and initialisation of properties (also called options)
\end_layout

\begin_layout Itemize
declaration of states
\end_layout

\begin_layout Itemize
definition of stable states
\end_layout

\begin_layout Itemize
definition of transitions
\end_layout

\begin_layout Itemize
definition of event handlers
\end_layout

\begin_layout Itemize
definition of commands
\end_layout

\begin_layout Itemize
export declarations
\end_layout

\begin_layout Standard
These sections are only for conceptual convenience; declarations and definitions
 can be freely intermixed but the order that stable states are declared
 is important.
 Please refer to section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Machines"

\end_inset

 for more information about the definition of machines.
\end_layout

\begin_layout Subsection
Expressions
\end_layout

\begin_layout Standard
There are two uses of expressions within Clockwork: definition of states
 and calculation of values; conditions are boolean expressions whereas calculati
ons may produce any kind of result that a property can hold.
 Expressions are modelled on expressions in the C language; the operators
 and precedence can be found in Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Expression-operators"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="12" columns="6">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top" width="4cm">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Symbol
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Description
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Plus
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
binary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
adds the lhs and rhs
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Minus
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
binary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
subtracts rhs from lhs
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
*
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Times
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
binary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
multiplies lhs and rhs
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
/
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Integer Divide
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
binary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
divides lhs by rhs and truncates the result
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
modulus
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
binary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
returns the remainder after dividing lhs by rhs
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
^
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
XOR
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
binary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
returns the exclusive or of the lhs and rhs
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
OR
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
binary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
returns the result of a bitwise or operation on the lhs and rhs
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
&
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
AND
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
binary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
returns the result of a bitwise and operation on the lhs and rhs
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
&& or AND
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Boolean AND
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
binary (bool)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
performs a boolean and of the expressions on the lhs and rhs
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|| or OR
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Boolean OR
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
binary (bool)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
performs the result of an or operation on the expressions on the lhs and
 rhs
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
!
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Negate
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
unary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
returns the bitwise inverse of the rhs
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
C-based Expression operators
\begin_inset CommandInset label
LatexCommand label
name "tab:Expression-operators"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Machines
\begin_inset CommandInset label
LatexCommand label
name "sec:Machines"

\end_inset


\end_layout

\begin_layout Standard
Machines are the core of clockwork programming; they define a virtual representa
tion of the operation of real machines or processes and in so doing provide
 a correspondence between the state of the program and the state of the
 machinery in the real world.
\end_layout

\begin_layout Standard
To define a machine use:
\emph on
 class_name 
\emph default
MACHINE 
\emph on
parameter1, parameter2, ...
 
\emph default
{ } and place the definition between the braces.
 
\end_layout

\begin_layout Standard
To create an instance of a machine, use: 
\emph on
name
\emph default
 
\emph on
class_name
\emph default
 
\emph on
param1, param2, ...
 
\emph default
;.
 There can be any number of instances for a given machine definition.
 The trick is mostly to do with what goes between the braces.
 
\end_layout

\begin_layout Subsection
State definitions
\end_layout

\begin_layout Standard
States can be defined by providing a name along with the 'STATE' keyword
 as follows: 
\emph on
state_name
\emph default
 
\noun on
STATE
\noun default
.
 When the machine enters a state, a script can be invoked to cause behaviour,
 often resulting in other state changes.
\end_layout

\begin_layout Standard
Such states can be used within transitions to define how the state of the
 machine changes in response to events.
 For example, the following states flip from one to the other continuously:
\end_layout

\begin_layout LyX-Code
off STATE;
\end_layout

\begin_layout LyX-Code
on STATE;
\end_layout

\begin_layout LyX-Code
ENTER off { SET SELF TO on }
\end_layout

\begin_layout LyX-Code
ENTER on { SET SELF TO off }
\end_layout

\begin_layout Standard
In the above example, the keyword `SELF' refers to the current state of
 the machine executing the script.
 the SET..TO..
 statement causes the state to change to the named state.
\end_layout

\begin_layout Subsubsection
Stable States
\end_layout

\begin_layout Standard
The definition of machines with a set of states and actions is a common
 approach and works well for describing event driven processes.
 In clockwork, machines are repeatedly monitoring their inputs to ensure
 that the machine's state is consistent with the definition of that state.
 When the machine's input change to a configuration that implies the external
 system has changed, clockwork machines automatically shift to the first
 state they can find that matches the measured conditions.
\end_layout

\begin_layout Standard
Clockwork can automatically check a set of rules to determine what state
 a machine is in.
 This is used by applying a WHEN clause to a state name:
\end_layout

\begin_layout LyX-Code
busy WHEN customers > 0;
\end_layout

\begin_layout LyX-Code
idle WHEN customers == 0;
\end_layout

\begin_layout Standard
The above states, `busy' and `idle' switch automatically depending on the
 property `customers'.
 We call theses `stable' states based on the idea that the machine finds.
 Stable state tests are performed in order and stop evaluating as soon as
 a match is found.
\end_layout

\begin_layout Standard
As another example, the following machine tries to stay in an inverted state
 compared to its input:
\end_layout

\begin_layout LyX-Code
Inverted MACHINE input {
\end_layout

\begin_deeper
\begin_layout LyX-Code
on WHEN input == off; 
\end_layout

\begin_layout LyX-Code
off DEFAULT
\end_layout

\end_deeper
\begin_layout LyX-Code
} 
\end_layout

\begin_layout Standard
At first glance, it seems that all instances of `Inverted' will always move
 to the opposite state of their inputs.
 However, in clockwork, we do not formally require that machines conform
 to any particular interface, for example, the only requirement in the above
 'Inverted' machine is that the input might at some time enter the 'off'
 state and when this happens, the Inverted machine will be 'on'.
 
\end_layout

\begin_layout Standard
Both the input and the inverted machine may be in the same state for short
 times, for example, for a short time after the machines are first enabled,
 they will both be in the 'INIT' state.
 Also using the above definition we cannot guarantee that the inverted machine
 is actually the inverse of the input since the input may have pass through
 other states and during all of these states, the inverted machine will
 stay 'off'.
 
\end_layout

\begin_layout Standard
The above definition may be made more strict by tightening the definition
 of the off state:
\end_layout

\begin_layout LyX-Code
Inverted MACHINE input {
\end_layout

\begin_deeper
\begin_layout LyX-Code
on WHEN input == off; 
\end_layout

\begin_layout LyX-Code
off WHEN input == on;
\end_layout

\begin_layout LyX-Code
unknown DEFAULT;
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
This definition enables us to be more confident in claiming the machine
 to be an inversion but if the input machine has many other states we may
 have to deal with the `unknown' state in some way.
 In practice, the previous definition is quite practical and these subtle
 distinctions are not helpful to the modelling process.
\end_layout

\begin_layout Subsection
Transitions
\end_layout

\begin_layout Standard
Transitions define how a system changes state based on the receipt of an
 event or command.
 Transitions can:
\end_layout

\begin_layout Itemize
be used to prevent arbitrary state changes
\end_layout

\begin_layout Itemize
can be guarded by requirements that must be met for the transtion to occur
\end_layout

\begin_layout Itemize
can define a command to execute when a machine is set into a state by another
 machine
\end_layout

\begin_layout Standard
The following Machine changes between a `ready' and `started' state when
 a start or stop command is received.
\end_layout

\begin_layout LyX-Code
StartStopTimer MACHINE {
\end_layout

\begin_deeper
\begin_layout LyX-Code
ready INITIAL; started STATE;
\end_layout

\begin_layout LyX-Code
COMMAND stop { timer := TIMER; } 
\end_layout

\begin_layout LyX-Code
COMMAND start { } 
\end_layout

\begin_layout LyX-Code
TRANSITION started TO ready ON stop; 
\end_layout

\begin_layout LyX-Code
TRANSITION ready TO started ON start; 
\end_layout

\end_deeper
\begin_layout LyX-Code
} 
\end_layout

\begin_layout Standard
The following machine steps through states upon receipt of the `next' command
 but may not transtion if the appropriate 'finished' flag is not set.
 This example uses an advanced feature that automatically sets a FLAG value
 as part of the stable state evaluation.
 While the `next' command is executing, the Machine enters the 'changing'
 state.
 In this example this is important because a transtion to a stable state
 can not occur if the condition for the stable state is not true.
 In this example, if the `next' command had any actions, those actions would
 be executed each time the event occurs but the automatic transtion will
 not occur if the requirement is not met.
\end_layout

\begin_layout LyX-Code
Cycle MACHINE {
\end_layout

\begin_deeper
\begin_layout LyX-Code
a_finished FLAG;
\end_layout

\begin_layout LyX-Code
b_finished FLAG;
\end_layout

\begin_layout LyX-Code
c_finished FLAG;
\end_layout

\begin_layout LyX-Code
a WHEN SELF IS a OR SELF IS INIT OR SELF IS changing,
\end_layout

\begin_deeper
\begin_layout LyX-Code
TAG a_finished WHEN TIMER > 5000;
\end_layout

\end_deeper
\begin_layout LyX-Code
b WHEN SELF IS b OR SELF IS changing,
\end_layout

\begin_deeper
\begin_layout LyX-Code
TAG b_finished WHEN TIMER > 5000;
\end_layout

\end_deeper
\begin_layout LyX-Code
c WHEN SELF IS c OR SELF IS changing,
\end_layout

\begin_deeper
\begin_layout LyX-Code
TAG c_finished WHEN TIMER > 5000;
\end_layout

\end_deeper
\begin_layout LyX-Code
ENTER a { SET a_finished TO off }
\end_layout

\begin_layout LyX-Code
ENTER b { SET b_finished TO off }
\end_layout

\begin_layout LyX-Code
ENTER c { SET c_finished TO off }
\end_layout

\begin_layout LyX-Code
changing DURING next { }
\end_layout

\begin_layout LyX-Code
TRANSITION a TO b ON next REQUIRES a_finished IS on;
\end_layout

\begin_layout LyX-Code
TRANSITION b TO c ON next REQUIRES b_finished IS on;
\end_layout

\begin_layout LyX-Code
TRANSITION c TO a ON next REQUIRES c_finished IS on;
\end_layout

\end_deeper
\begin_layout LyX-Code
} 
\end_layout

\begin_layout Subsection
State Transitions
\end_layout

\begin_layout Standard
When a machine changes state, several stages occur: 
\end_layout

\begin_layout Enumerate
if the machine has a leave action it is started
\end_layout

\begin_layout Enumerate
when the leave action is completed the current state of the machine is changed
\end_layout

\begin_layout Enumerate
once the machine state has changed the enter action for the state is started
 if there is one
\end_layout

\begin_layout Enumerate
if the machine has dependencies those machines are told the machine is entering
 a state
\end_layout

\begin_layout Subsection
Event handlers (methods)
\end_layout

\begin_layout Standard
Event handlers are commands that execute when a machine changes state.
 Currently handlers are executed upon entry to a state but no handler is
 called when the system leaves a state (this is a topic for future).
\end_layout

\begin_layout Subsection
Commands
\end_layout

\begin_layout Standard
Commands are lists of actions that are executed in response to receipt of
 a message.
 While commands are being executed, the stable state evaluation for a machine
 are not executed.
 Commands may have an associated state that the machine moves to while executing
 the actions.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
The mechanism for this will be to add clauses to identify timeouts or other
 conditions:
\end_layout

\begin_layout LyX-Code
COMMAND example { statements } ON ERROR message
\end_layout

\begin_layout Standard
or
\end_layout

\begin_layout LyX-Code
COMMAND example { statements } ON TIMEOUT message
\end_layout

\begin_layout Subsection
Exporting properties
\end_layout

\begin_layout Standard
A machine can export its properties for use by Modbus applications through
 use of the EXPORT statement...
\end_layout

\begin_layout Subsection
Lists
\end_layout

\begin_layout Standard
Machines can be grouped together into lists.
 Lists have some features and restrictions:
\end_layout

\begin_layout Itemize
machines may be placed on a list but every entry in the list must be unique,
 attempting to include an item a second time leads to undefined bahaviour
\end_layout

\begin_layout Itemize
messages sent to a list are also sent to all entries of the list
\end_layout

\begin_layout Itemize
entries of a list remain in the order they are added (ie., the INCLUDE statement
 adds an elment to the end of the list) unless the list order is changed
 by a SORT statement
\end_layout

\begin_layout Itemize
lists can be reordered by using a property of the entries as the sort key,
 by default the VALUE property is used
\end_layout

\begin_layout Itemize
lists entry states or properties can be packed into an binary value property
 using the BITSET FROM statement and can be restored using the SET LIST
 ENTRIES statement
\end_layout

\begin_layout Itemize
items can be tested to see if a list contains a reference to them (eg., my_list
 INCLUDES my_machine)
\end_layout

\begin_layout Itemize
set operations are available to load lists based on operations involving
 other lists
\end_layout

\begin_layout Subsection
Monitoring globals
\end_layout

\begin_layout Standard
Generally a Machine will only receive events from machines that are passed
 as parameters or that are included within the Machine.
 By using the GLOBAL keyword, a Machine can monitor state changes on other
 machines, not passed as parameters.
 By this technique, it is possible to avoid passing parameters to machines
 and to simply refer to all machines globally.
 This is probably fine for small systems but less practical for larger systems.
\end_layout

\begin_layout Subsection
References
\end_layout

\begin_layout Standard
The builtin machine, REFERENCE provides a way to link machines together.
 When an object is assigned to a reference, the reference enters the ASSIGNED
 state, when the reference is cleared, it enters the UNASSIGNED state.
 Other machines can detect these changes by listening for ASSIGNED_enter
 or UNASSIGNED_enter mesages.
 If an assignment is attempted to a non-existent machine any preexisting
 assignment is cleared and the new assignment fails.
\end_layout

\begin_layout Section
Subtleties
\end_layout

\begin_layout Subsection
Enabling and disabling machines
\end_layout

\begin_layout Standard
Machines in clockwork may be prevented from operating by disabling them.
 Messages sent to disabled machines are silently ignored and attempts to
 set the state of a disabled machine triggers an exception.
 TBD more information about interactions with disabled machines.
\end_layout

\begin_layout Subsection
Controlling startup
\end_layout

\begin_layout Standard
When the clockwork environment starts, all machines initially disabled and
 are enabled depending on the following rules:
\end_layout

\begin_layout Standard
if the application program implements a machine with the class 'STARTUP',
 only that machine is enabled and the entire startup process is left to
 application control.
\end_layout

\begin_layout Standard
if there is no instance of a 'STARTUP' machine machines that have a property:
 'startup_enabled' with a value of false are not enabled and all other machines
 are enabled.
\end_layout

\begin_layout Standard
The system attempts to start machines in order such that machines passed
 as paremeters to other machines are enabled first.
\end_layout

\begin_layout Standard
Machines that include a 'DEPENDS ON' clause can only enabled when the named
 machine has been enabled.
 If the named machine does not exist it is not possible to enable the dependent
 machines.
 In the case where the application does not provide a STARTUP machine, when
 the machines that are the object of a DEPENDS ON clause are enabled or
 disabled those machines that depend on them are automatically enabled or
 disabled.
\end_layout

\begin_layout Section
Details
\end_layout

\begin_layout Subsection
Instances of machines
\end_layout

\begin_layout Standard
Clockwork deals primarily with definitions of finite state machines (referred
 to as MACHINES in the language) and instance of those definitions.
 There is a common pattern for declaring an instance of a machine; providing
 the name and then the machine class.
\end_layout

\begin_layout Standard
Names can be given for new instances of objects, by first providing the
 name, then the object and its properties and parameters, i.e.,
\end_layout

\begin_layout Quotation
name machine-class [ '(' property-name ':' property-value ...
 ')'] parameters
\end_layout

\begin_layout Standard
For example, given machine classes called `MODULE' and `POINT', an instance
 can be declared in the following way.
\end_layout

\begin_layout LyX-Code
Beckhoff_2008 MODULE 2
\end_layout

\begin_layout LyX-Code
NG_Output POINT Beckhoff_2008 5
\end_layout

\begin_layout Standard
define a Module and a point within that module.
 In the example, the number `2' indicates the position of the module on
 the bus and the number `5' defines the particular output id of the point
 that we want to call `NG_Output'.
 After the object-class, a list of property key,value pairs may be given.,
 for example
\end_layout

\begin_layout LyX-Code
NG_Output POINT (tab:Outputs) Beckhoff_2008 5
\end_layout

\begin_layout Standard
describes the same point but sets a property called `tab'
\begin_inset Foot
status open

\begin_layout Plain Layout
The web interface to cw and iod happen to use this property to group various
 items into tabs on the web page
\end_layout

\end_inset

 to the value `Outputs'.
\end_layout

\begin_layout Subsection
Properties and states
\end_layout

\begin_layout Standard
We make a distinction between the state of a machine and the properties
 of the machine, in fact, we regard the state of the machine as one of its
 properties although more strictly, we should actually include the value
 of a machine's properties as part of its state.
 The definitions are 
\end_layout

\begin_layout Subsection
Properties and parameters
\end_layout

\begin_layout Standard
As shown, the declaration of a machine may have parameters and machines
 may also have properties.
 Properties and parameters are distinguished as follows:
\end_layout

\begin_layout Itemize
properties have default values and do not have to be predeclared unless
 they are used in stable state conditions
\end_layout

\begin_layout Itemize
parameters generally refer to objects that the machine manipulates and serve
 to provide an internal alias for a globally defined object.
 Use of parameters provides for the reuse of machines for different parts
 of the system.
\end_layout

\begin_layout Itemize
when a parameter changes state, the machine receives an event that it may
 act on to perform an action.
\end_layout

\begin_layout Itemize
when a property of a machine or one of its parameters or local variables
 is changed, the machine reevaluates its stable states.
\end_layout

\begin_layout Section
Vocabulary
\end_layout

\begin_layout Standard
Within the program text, reserved words are presented in all capitals to
 distinguish them from user defined values.
 The language is case sensitive.
\end_layout

\begin_layout Subsection
Glossary of Reserved Words 
\end_layout

\begin_layout Description
16BIT defines an exported modbus property as a 16bit integer
\end_layout

\begin_layout Description
32BIT defines an exported modbus property as a 32bit integer
\end_layout

\begin_layout Description
ALL used with COPY and EXTRACT to collect all matches from a property
\end_layout

\begin_layout Description
AND (also &&) used to join expressions within a condition
\end_layout

\begin_layout Description
AT used with RESUME to cause execution to resume at a nominated state
\end_layout

\begin_layout Description
BECOMES (also :=) used to assign values to properties
\end_layout

\begin_layout Description
BY used with INC and DEC to change the step size
\end_layout

\begin_layout Description
CALL sends a message to a machine and waits for completion of handlers attached
 to that message.
\end_layout

\begin_layout Description
CATCH marks the beginning of an operation to be performed if any sends a
 particular message.
 [not implemented]
\end_layout

\begin_layout Description
COMMAND defined a method that does not change the state of its machine while
 it is executing.
\end_layout

\begin_layout Description
CONSTANT a predefined machine class that acts like a constant from a syntactic
 viewpoint
\end_layout

\begin_layout Description
COPY copies substrings matching a pattern from a given property
\end_layout

\begin_layout Description
DEC decrement a property
\end_layout

\begin_layout Description
DEFAULT a stable state that is evaluated last and that always matches
\end_layout

\begin_layout Description
DISABLE is used to make a machine unable to respond to requests to change
 state or process commands.
 Properties of a disabled machine can still be changed.
 The machine stays in the state it was is when it was disabled/ 
\end_layout

\begin_layout Description
DURING used to define a transitional state that occurs during the exectuion
 of a command
\end_layout

\begin_layout Description
EXECUTE extends the definition of a stable state to specify a command that
 should be executed when a special sub-condition becomes active.
\end_layout

\begin_layout Description
ELSE marks the beginning of the code that is executed when the IF condition
 evaluates to false
\end_layout

\begin_layout Description
ENABLE makes a machine able to respond to requests and changes state.
 The machine enters its initial state and executes the initial state entry
 method.
 The leave event to the previous state is also executed and the message
 is sent to dependent machines.
\end_layout

\begin_layout Description
ENTER defines an operation that must be performed during entry to a state.
 The ENTER function may be restricted to performing functions that are atomic,
 such as sending message.
 Currently, these operations are not restricted but cause the machine to
 enter an invisible substate of the target state.
\end_layout

\begin_layout Description
EXPORT indicates that a property should be exported to modbus
\end_layout

\begin_layout Description
FIND returns a list of objects that are in the given state, options may
 be added to restrict the range of items found [not implemented]
\end_layout

\begin_layout Description
FOREACH performs an operation for each object within the given list that
 are in a particular state [not implemented]
\end_layout

\begin_layout Description
GLOBALS lists machines, external to the current class that the current machine
 is monitoring.
 State changes on the machines listed as GLOBAL cause a reevaluation of
 stable states and generate events that can be received.
\end_layout

\begin_layout Description
INC increment a property
\end_layout

\begin_layout Description
IF used within operations (Commands and Enter functions) to provide for
 conditional behaviour
\end_layout

\begin_layout Description
INIT a predefined state that statemachines enter as soon as they are enabled.
\end_layout

\begin_layout Description
INITIAL defines a state as the state to use for the initial state of the
 machine.
\end_layout

\begin_layout Description
LOG emit a text string in the log
\end_layout

\begin_layout Description
LOCK provides a way to mark a protected section to prevent, for example,
 multiple machines simultaneously changing the state of a machine.
\end_layout

\begin_layout Description
MATCHES used in an expression to test for a property matching a given pattern
\end_layout

\begin_layout Description
MACHINE defines a programmed component within the system.
 All control functionality is implemented within these objects.
 Machines are based on finite statemachine concept and include both monitoring
 (automatic state switching) and control (forced state changes to cause
 actions).
\end_layout

\begin_layout Description
MODULE defines an addressable module that sits on the EtherCAT cabling
\end_layout

\begin_layout Description
NOT (also !)used to invert expressions within a condition
\end_layout

\begin_layout Description
OR (also ||) used to join expressions within a condition
\end_layout

\begin_layout Description
PERSISTENT a property that indicates that propertye changes on this machine
 will be published.
 Machines marked as persistent are no longer automatically enabled on startup.
\end_layout

\begin_layout Description
POINT refers to an addressable port within a module or a builtin machine
 with that name (see Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Builtin-classes"

\end_inset

)
\end_layout

\begin_layout Description
RAISE send a message that any machine may catch.
 It is an error if a message is raised but not caught.
 [not implemented]
\end_layout

\begin_layout Description
READONLY used in an EXPORT specification to mark the property as read only
\end_layout

\begin_layout Description
READWRITE used in an EXPORT specification to mark the property as read/write
\end_layout

\begin_layout Description
RESULT the returned value after an expression has been evaluated [not implemente
d]
\end_layout

\begin_layout Description
RESUME resumes execution of the disabled machine from the beginning of its
 current state
\end_layout

\begin_layout Description
RECEIVE indicates that a machine should be informed when a specific object
 sends a particular message.
 The RECEIVE statement has an associated set of actions that are acted when
 the event is collected.
\end_layout

\begin_layout Description
REQUIRES indicates that the associated condition must evaluate to True in
 order that the transition can occur or that a command can be executed [not
 implemented]
\end_layout

\begin_layout Description
SELF used in expressions to refer 
\end_layout

\begin_layout Description
SEND is used to send a message to a machine, this message must be captured
 by the machine, using a RECEIVE statement
\end_layout

\begin_layout Description
SET causes a machine to move to a given state after executing the optional
 command associated with the transition
\end_layout

\begin_layout Description
SHUTDOWN cause the clockwork daemon to exit
\end_layout

\begin_layout Description
SOURCE is a variable that holds a reference to the object that send the
 current message or issued the current command [not implemented]
\end_layout

\begin_layout Description
STATE defines a state name so that this state can be used in a transition
 or can be set by other machines.
\end_layout

\begin_layout Description
TAG links a FLAG to a sub-condition on a stable state so that the FLAG is
 automatically turned on and off to trak whether the subcondition is true
 or not.
\end_layout

\begin_layout Description
THEN marks the beginning of the code that is executed when the IF condition
 evaluates to true
\end_layout

\begin_layout Description
TIMER
\end_layout

\begin_layout Description
TO used within a transition to indicate the destination state, used within
 a message operation to indicate the target of the message
\end_layout

\begin_layout Description
TRANSITION describes the command that can be used to move the machine from
 one state to another
\end_layout

\begin_layout Description
UNLOCK reverses the effect of LOCK, to permit other instances execute code
 in a critical section.
\end_layout

\begin_layout Description
USING as part of the transition statement, the Using clause indicates the
 command that is used for the transition
\end_layout

\begin_layout Description
VARIABLE a predefined machine class that is persistent and acts like a variable
 from a syntactic viewpoint
\end_layout

\begin_layout Description
WAIT pauses execution of the current method for the set amount of time
\end_layout

\begin_layout Description
WAITFOR pauses execution of the current method until the given machine enters
 the given state
\end_layout

\begin_layout Description
WHEN defines a set of conditions that indicate a machine is in a particular,
 stable state.
 These conditions are not evaluated when the machine is in a transitional
 state.
\end_layout

\begin_layout Subsection
Conditions
\end_layout

\begin_layout Standard
Conditions are lists of boolean expressions that are generally used to determine
 the current state of various parts of the machine.
 Conditions are implemented by the use of separate state machines.
 that contain a state (normally called 'true') that indicates the condition
 is true and a state (normally called 'false') that is the default.
\end_layout

\begin_layout Subsection
Notes
\end_layout

\begin_layout Standard
An action is a list of steps, such that each step requests that a machine
 enters a state or waits for a message.
 Regardless of the action, there are two components: sending a message and
 waiting for a response.
 On receipt of the response, the action transitions to the next step in
 the list.
\end_layout

\begin_layout Standard
When a state change request is received, the transitions on the target machine
 are searched for an action that will satisfy the requested state change.
 That action causes a further sequence of actions to be queued by having
 the machine enter a substate with each action sending a message and waiting
 for a response.
 
\end_layout

\begin_layout Section
Machines
\end_layout

\begin_layout Standard
Machines are the processing component of the latproc programming system.
 They are defined as finite state machines that are interconnected by message
 passing.
 A machine will automatically detect its state by polling input conditions
 that are defined to match certain configurations.
 By issuing commands, a machine can change the state of other machines and
 these changes can trigger further state changes.
\end_layout

\begin_layout Subsection
Components and scope
\end_layout

\begin_layout Standard
The language deals with Finite State Machines, which the language simply
 calls 'Machines' and their states.
 The program defines a machine as having certain states and provides conditions
 and scripts that can identify the current state and change states.
\end_layout

\begin_layout Standard
some predefined objects; Modules, Points, Machines, Values, Conditions and
 States.
 These objects may have parameters and may also have properties.
 Properties and parameters are distinguished as follows:
\end_layout

\begin_layout Itemize
properties have default values and do not have to be provided
\end_layout

\begin_layout Itemize
parameters generally refer to objects that the machine manipulates and serve
 to provide an internal alias for a globally defined object.
 Use of parameters provides for the reuse of machines for different parts
 of the system.
\end_layout

\begin_layout Subsection
Parameters
\end_layout

\begin_layout Standard
When a machine is instantiated, parameters are resolved by providing either
 a symbol name or a symbol value.
 The Machine Instance retains a list of ParameterReferences and for parameters
 passed by value, a local symbol table allocates a local name
\end_layout

\begin_layout Subsection
States
\end_layout

\begin_layout Standard
A state is defined by a particular configuration of inputs or execution
 of an action.
\end_layout

\begin_layout Subsection
Actions
\end_layout

\begin_layout Standard
An action is a sequence of steps that are executed in response to the receipt
 of a message, including steps taken dugin an entry function.
\end_layout

\begin_layout Subsection
Transitions
\end_layout

\begin_layout Standard
Transitions occur automatically when a machine is idle, when it detects
 a change of state.
 When a transition occurs:
\end_layout

\begin_layout Itemize
the timer is reset, 
\end_layout

\begin_layout Itemize
the state variable 'CURRENT' is updated
\end_layout

\begin_layout Itemize
a state change message is queued for delivery to interested parties
\end_layout

\begin_layout Itemize
the entry function for the state is executed
\end_layout

\begin_layout Subsection
Events
\end_layout

\begin_layout Standard
An event corresponds to the sending of a message.
 Examples of events include timers and changes in input levels or analogue
 or counter values.
 Timer events are intented to trigger reasonably precisely, based on a fixed
 time after the message was sent.
\end_layout

\begin_layout Subsection
Message Passing
\end_layout

\begin_layout Standard
Machines can send and receive messages directly, using the commands SEND
 and CALL and the handler RECEIVE or it can send messages indirectly by
 attempting to change the state of the target machine.
\end_layout

\begin_layout Subsubsection
RECEIVE and RECEIVE..FROM
\end_layout

\begin_layout Standard
Each machine can listen for messages from any entity it knows of.
 Messages are sent when entities change state or when a script deliberately
 sends one.
 To listen for a message, use:
\end_layout

\begin_layout Quotation
RECEIVE objname.message '{' actions '}'
\end_layout

\begin_layout Standard
or
\end_layout

\begin_layout Quotation
RECEIVE message FROM objname '{' actions '}'
\end_layout

\begin_layout Standard
This identifies the sending entity from its local name and registers a listener
 for the 
\emph on
entiyname_statename_enter
\emph default
 message.
 In a future release, the current machine will also registered as a dependant
 of the sender.
 Currently, messages are only received from parameters, local instances
 and machine instances that are specifically listed in GLOBALS.
\end_layout

\begin_layout Subsubsection
SEND and SEND..TO
\end_layout

\begin_layout Subsubsection
CALL
\end_layout

\begin_layout Standard
The CALL statement acts like theSEND except that the statement hangs and
 waits for a response from the target.
 There are a few forms:
\end_layout

\begin_layout Standard
CALL command
\end_layout

\begin_layout Standard
CALL command ON ERROR CALL command
\end_layout

\begin_layout Standard
CALL command, EXECUTE command WHEN predicate
\end_layout

\begin_layout Subsection
Exceptions
\end_layout

\begin_layout Standard
[Note: not implemented]An exception is a message sent using the 'THROW'
 command.
 It is similar to a message sent with 'SEND' except that there is no requirement
 that there is a machine listening for the message.
 Messages that are thrown are caught using the 'CATCH' command.
\end_layout

\begin_layout Subsection
Statements
\end_layout

\begin_layout Subsection
Properties
\end_layout

\begin_layout Standard
Machine instances share some standard properties
\end_layout

\begin_layout Description
current the current state of the instance
\end_layout

\begin_layout Description
referers a list of machinesthat refer to this machine
\end_layout

\begin_layout Description
references a list of machines this one refers to
\end_layout

\begin_layout Description
sends a list of messages this machine sends
\end_layout

\begin_layout Description
receives a list of messages this machine receives
\end_layout

\begin_layout Subsection
Expressions
\end_layout

\begin_layout Standard
Expressions are based on C language expressions, standard arithmetic and
 bitwise operations are supported (with the exception at the moment of bitwise
 shift operators).
\end_layout

\begin_layout Subsection
Builtin classes
\begin_inset CommandInset label
LatexCommand label
name "subsec:Builtin-classes"

\end_inset


\end_layout

\begin_layout Standard
Builtin classes such as FLAG and BOOLEAN are readily implemented using the
 language itself.
 The POINT class, however is special as it provides an interface to hardware.
 Integers are currnetly implemented through properties.
\end_layout

\begin_layout Description
VARIABLE
\end_layout

\begin_layout Description
MODULE
\end_layout

\begin_layout Description
CONSTANT
\end_layout

\begin_layout Description
FLAG two state machine with states 'on' and 'off'
\end_layout

\begin_layout Description
POINT a machine that links to a IO Point or a digital value accessible through
 the Internet of Things protocol.
\end_layout

\begin_layout Description
PUBLISHER a machine that publishes changes to its 'message' property to
 Internet Of Things brokers using its 'topic' property for the IoT topic.
\end_layout

\begin_layout Description
SUBSCRIBER a machine that subscribes to messages from Internet Of Things
 brokers to update its 'message' property when changes occur on the topic
 named in its 'topic' property.
\end_layout

\begin_layout Section
Other features
\end_layout

\begin_layout Subsection
Expressions
\end_layout

\begin_layout Standard
Recently added
\end_layout

\begin_layout Itemize
XOR (`^')
\end_layout

\begin_layout Itemize
Bitwise AND ('&'), OR ('|') and negate ('!')
\end_layout

\begin_layout Section
Syntax
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
program & = & \mathit{definition}\,program\,|\,Ã\\
\mathcal{\mathit{definition}} & = & name\,object\,parameterlist\\
parameters & = & parameter\,|\,parameter\,','\,parameter\\
parameter & = & value\,parameter\,|\,Ã
\end{eqnarray*}

\end_inset


\end_layout

\end_body
\end_document
