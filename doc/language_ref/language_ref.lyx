#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass extbook
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\topmargin 1in
\rightmargin 2cm
\bottommargin 2cm
\headheight 1cm
\headsep 1cm
\footskip 1cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle headings
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Clockwork Language Reference
\end_layout

\begin_layout Author
Martin Leadbeater
\end_layout

\begin_layout Date
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
today
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Chapter
Overview
\end_layout

\begin_layout Section
Preface
\end_layout

\begin_layout Standard
This desribes the Clockwork language, the User Guide and Programming Guide
 provide additional information that will help newcomers learn to program
 in Clockwork.
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
Clockwork is a language intended to be used to describe systems of interacting
 components using state machines.
 The purpose of the language is to provide a platform for monitoring and
 control and it has currently been implemented as a control system using
 Beckhoff EtherCATÂ® and The Internet of Things (MQTT).
\end_layout

\begin_layout Standard
The language provides the programmer with a means to:
\end_layout

\begin_layout Itemize
define the states of a machine in terms of conditions
\end_layout

\begin_layout Itemize
define commands that can be invoked on the machine
\end_layout

\begin_layout Itemize
define transition rules that determine what actions can be performed and
 what state transtions are allowable
\end_layout

\begin_layout Itemize
define state entry functions that execute when a machine enters a state
\end_layout

\begin_layout Itemize
monitor the operation of a machine by sampling events as they occur and
 interactively inspecting the state and properties of internal components
\end_layout

\begin_layout Itemize
view the state and properties of the machine in a web browser
\end_layout

\begin_layout Itemize
view the operation of a machine in a 3D view
\end_layout

\begin_layout Itemize
interface to serial devices, network devices and modbus devices
\end_layout

\begin_layout Itemize
program embedded devices and microcontrollers (not yet available)
\end_layout

\begin_layout Subsection
Elements of a clockwork system
\end_layout

\begin_layout Standard
A clockwork system consists of 
\end_layout

\begin_layout Description
state-machines which are the components that contain the properties and
 behaviour of the system
\end_layout

\begin_layout Description
EtherCAT which is the main hardware IO platform for clockwork
\end_layout

\begin_layout Description
channels which connect separate instances of clockwork together or connect
 clockwork to other tools
\end_layout

\begin_layout Description
hmi whether it is a web application, humid user interface or command interface
\end_layout

\begin_layout Description
monitors implemented via the external sampler/scope tools or via tools within
 humid
\end_layout

\begin_layout Description
connections to non-clockwork systems such as TCP/IP connections, MQTT or
 serial devices
\end_layout

\begin_layout Section
Review of the language
\end_layout

\begin_layout Standard
For a more detailed discussion of programming in clockwork, please refer
 to the Programming Guide or User Guide.
\end_layout

\begin_layout Standard
The main components in a Clockwork program are called Machines.
 Machines are the processing component of the latproc suite.
 They are defined as finite state machines that are interconnected by message
 passing.
 A machine will automatically detect its state by polling input conditions
 that are defined to match certain configurations.
 By issuing commands, a machine can change the state of other machines and
 these changes can trigger further state changes.
\end_layout

\begin_layout Subsection
Machines
\end_layout

\begin_layout Standard
A Machine is similar to a Class in other languages in that it encapsulates
 state and provides methods that implement procedural logic.
 Machines are different to classes in that they execute as independent entities,
 continuously evaluating the state of their environment and reacting to
 it.
 Machines are models of processing components or real-world devices that
 can be interconnected.
 Each Machine has a current state and (normally) several other states that
 the machine may automatically move to or that can be manually set by processing
 steps in the program.
 Normally the state of a system includes all of its properties and their
 current values.
 We make a distinction, however, between the state of a machine and the
 properties of the machine, and let the rules determine how the value of
 a machines properties determine its state.
 
\end_layout

\begin_layout Standard
State-machine based modeling systems, clockwork included, use transition
 tables that describe state changes in response to events.
 The key difference between Clockwork and other state machine systems is
 that in Clockwork the software components can also automatically move between
 states by monitoring a set of rules.
 When a state includes a condition, we tend to refer to that as a 
\emph on
stable 
\emph default
state but these could also be called 
\emph on
automatic
\emph default
 states.
 
\end_layout

\begin_layout Standard
A machine is defined by a block of code that defines the states and rules
\end_layout

\begin_layout LyX-Code
<machine-class-name> 
\begin_inset Quotes eld
\end_inset

MACHINE
\begin_inset Quotes erd
\end_inset

 <parameter> [, parameter] ...
\end_layout

\begin_layout LyX-Code
\begin_inset Quotes eld
\end_inset

{
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_deeper
\begin_layout LyX-Code
<state-name> 
\begin_inset Quotes eld
\end_inset

WHEN
\begin_inset Quotes erd
\end_inset

 <rule> 
\begin_inset Quotes eld
\end_inset

;
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout LyX-Code
[...]
\end_layout

\begin_layout LyX-Code
[ <state-name> DEFAULT 
\begin_inset Quotes eld
\end_inset

;
\begin_inset Quotes erd
\end_inset

 ]
\end_layout

\end_deeper
\begin_layout LyX-Code
\begin_inset Quotes eld
\end_inset

}
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
A rule is simply a predicate expression that compares various properties
 and values; it evaluates to eithe 
\emph on
true
\emph default
 or 
\emph on
false
\emph default
 For example, here is a definition for a Machine that behaves like an AND
 gate in an electronic circuit; an AND gate is on only when both inputs
 are on:
\end_layout

\begin_layout LyX-Code
AndGate MACHINE input1, input2
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_deeper
\begin_layout LyX-Code
on WHEN input1 IS on AND input2 IS on;
\end_layout

\begin_layout LyX-Code
off DEFAULT
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\begin_layout Subsection
Instances of machines
\end_layout

\begin_layout Standard
Clockwork deals primarily with definitions of finite state machines (referred
 to as MACHINES in the language) and instance of those definitions.
 There is a common pattern for declaring an instance of a machine; providing
 the name and then the machine class.
 The same pattern of name then element is used in most parts of the language.
\end_layout

\begin_layout Standard
Other things, such as properties and parameters or action blocks follow
 after the name/element pair; for example:
\end_layout

\begin_layout Quotation
name machine-class [ '(' property-name ':' property-value ...
 ')'] parameters
\end_layout

\begin_layout Standard
For example, given machine classes called `MODULE' and `POINT', an instance
 can be declared in the following way.
\end_layout

\begin_layout LyX-Code
Beckhoff_2008 MODULE 2
\end_layout

\begin_layout LyX-Code
NG_Output POINT Beckhoff_2008 5
\end_layout

\begin_layout Standard
This defines a Module and a point within that module.
 In the example, the number `2' indicates the position of the module on
 the bus and the number `5' defines the particular output id of the point
 that we want to call `NG_Output'.
 After the object-class, a list of property key,value pairs may be given.,
 for example
\end_layout

\begin_layout LyX-Code
NG_Output POINT (tab:Outputs) Beckhoff_2008 5
\end_layout

\begin_layout Standard
describes the same point but sets a property called `tab'
\begin_inset Foot
status open

\begin_layout Plain Layout
The web interface to cw and iod happen to use this property to group various
 items into tabs on the web page
\end_layout

\end_inset

 to the value `Outputs'.
\end_layout

\begin_layout Subsection
Properties and parameters
\end_layout

\begin_layout Standard
As shown, the declaration of a machine may have parameters and machines
 may also have properties.
 Properties and parameters are distinguished as follows:
\end_layout

\begin_layout Itemize
properties have default values and do not have to be predeclared unless
 they are used in stable state conditions
\end_layout

\begin_layout Itemize
parameters generally refer to objects that the machine manipulates and serve
 to provide an internal alias for a globally defined object.
 Use of parameters provides for the reuse of machines for different parts
 of the system.
\end_layout

\begin_layout Itemize
when a parameter changes state, the machine receives an event that it may
 act on to perform an action.
\end_layout

\begin_layout Itemize
when a property of a machine or one of its parameters or local variables
 is changed, the machine reevaluates its stable states.
\end_layout

\begin_layout Standard
The above machine 
\emph on
definition
\emph default
 for this AndGate requires two 
\emph on
parameters
\emph default
 for the two inputs and defines a rule on state `on' that will activate
 when both inputs are on.
 The statement 
\noun on
'
\family typewriter
\noun default
off DEFAULT
\family default
\noun on
'
\noun default
 defines a default condition on the 
\family typewriter
off
\family default
 state that always returns true.
 There can be only one DEFAULT state in each machine but it is not required;
 the presence of a default state ensures that machines of this type will
 be in the on state when the condition is true and only when the condition
 is true.
\end_layout

\begin_layout Standard
A machine definition can be instantiated by providing a name, the name of
 the machine definition, also called the machine `machine class', and a
 list or parameters that are required by the definition.
 
\end_layout

\begin_layout LyX-Code
<instantiated-name> <machine-class-name> [ <parameter> [ , <parameter> ...
 ] ] 
\begin_inset Quotes eld
\end_inset

;
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
For example, following is a machine named 'and_gate' that used the definition
 'AndGate' and takes two other machines as parameters:
\end_layout

\begin_layout LyX-Code
and_gate AndGate a, b;
\end_layout

\begin_layout LyX-Code
a FLAG;
\end_layout

\begin_layout LyX-Code
b FLAG;
\end_layout

\begin_layout Standard
Note that the FLAG machine type is defined internally in the language and
 at this stage it can be regarded as a machine defined like this:
\end_layout

\begin_layout LyX-Code
FLAG MACHINE
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_deeper
\begin_layout LyX-Code
on STATE;
\end_layout

\begin_layout LyX-Code
off INITIAL;
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
Thus a FLAG can be either on or off and is initially off.
 There are no rules to define how the machine might automatically move between
 those states so it is left to other parts of the program to change the
 state of the FLAG as required.
\end_layout

\begin_layout Subsection
State Transitions
\end_layout

\begin_layout Standard
When a machine changes state, several stages occur: 
\end_layout

\begin_layout Enumerate
if the machine has a leave action it is started
\end_layout

\begin_layout Enumerate
when the leave action is completed the current state of the machine is changed
\end_layout

\begin_layout Enumerate
once the machine state has changed the enter action for the state is started
 if there is one
\end_layout

\begin_layout Enumerate
if the machine has dependencies those machines are told the machine is entering
 a state
\end_layout

\begin_layout Subsection
Expressions
\end_layout

\begin_layout Standard
There are two uses of expressions within Clockwork: definition of states
 and calculation of values; conditions are boolean expressions whereas calculati
ons may produce any kind of result that a property can hold.
 Expressions are modelled on expressions in the C language; the operators
 and precedence can be found in Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Expression-operators"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="12" columns="6">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top" width="4cm">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Symbol
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Description
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Plus
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
binary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
adds the lhs and rhs
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Minus
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
binary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
subtracts rhs from lhs
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
*
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Times
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
binary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
multiplies lhs and rhs
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
/
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Integer Divide
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
binary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
divides lhs by rhs and truncates the result
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
modulus
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
binary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
returns the remainder after dividing lhs by rhs
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
^
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
XOR
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
binary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
returns the exclusive or of the lhs and rhs
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
OR
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
binary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
returns the result of a bitwise or operation on the lhs and rhs
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
&
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
AND
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
binary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
returns the result of a bitwise and operation on the lhs and rhs
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
&& or AND
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Boolean AND
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
binary (bool)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
performs a boolean and of the expressions on the lhs and rhs
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|| or OR
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Boolean OR
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
binary (bool)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
performs the result of an or operation on the expressions on the lhs and
 rhs
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
!
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Negate
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
unary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
returns the bitwise inverse of the rhs
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
C-based Expression operators
\begin_inset CommandInset label
LatexCommand label
name "tab:Expression-operators"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Passive states
\end_layout

\begin_layout Standard
States can be defined by providing a name along with the 'STATE' keyword
 as follows: 
\emph on
state_name
\emph default
 
\noun on
STATE
\noun default
.
 When the machine enters a state, a script can be invoked to cause behaviour,
 often resulting in other state changes.
\end_layout

\begin_layout Standard
Such states can be used within transitions to define how the state of the
 machine changes in response to events.
 For example, the following states flip from one to the other continuously:
\end_layout

\begin_layout LyX-Code
off STATE;
\end_layout

\begin_layout LyX-Code
on STATE;
\end_layout

\begin_layout LyX-Code
ENTER off { SET SELF TO on }
\end_layout

\begin_layout LyX-Code
ENTER on { SET SELF TO off }
\end_layout

\begin_layout Standard
In the above example, the keyword `SELF' refers to the current state of
 the machine executing the script.
 the SET..TO..
 statement causes the state to change to the named state.
\end_layout

\begin_layout Subsection
Stable States
\end_layout

\begin_layout Standard
The definition of machines with a set of states and actions is a common
 approach and works well for describing event driven processes.
 In clockwork, machines are repeatedly monitoring their inputs to ensure
 that the machine's state is consistent with the definition of that state.
 When the machine's input change to a configuration that implies the external
 system has changed, clockwork machines automatically shift to the first
 state they can find that matches the measured conditions.
\end_layout

\begin_layout Standard
Clockwork can automatically check a set of rules to determine what state
 a machine is in.
 This is used by applying a WHEN clause to a state name:
\end_layout

\begin_layout LyX-Code
busy WHEN customers > 0;
\end_layout

\begin_layout LyX-Code
idle WHEN customers == 0;
\end_layout

\begin_layout Standard
The above states, `busy' and `idle' switch automatically depending on the
 property `customers'.
 We call theses `stable' states based on the idea that the machine finds.
 Stable state tests are performed in order and stop evaluating as soon as
 a match is found.
\end_layout

\begin_layout Standard
As another example, the following machine tries to stay in an inverted state
 compared to its input:
\end_layout

\begin_layout LyX-Code
Inverted MACHINE input {
\end_layout

\begin_deeper
\begin_layout LyX-Code
on WHEN input == off; 
\end_layout

\begin_layout LyX-Code
off DEFAULT
\end_layout

\end_deeper
\begin_layout LyX-Code
} 
\end_layout

\begin_layout Standard
At first glance, it seems that all instances of `Inverted' will always move
 to the opposite state of their inputs.
 However, in clockwork, we do not formally require that machines conform
 to any particular interface, for example, the only requirement in the above
 'Inverted' machine is that the input might at some time enter the 'off'
 state and when this happens, the Inverted machine will be 'on'.
 
\end_layout

\begin_layout Standard
Both the input and the inverted machine may be in the same state for short
 times, for example, for a short time after the machines are first enabled,
 they will both be in the 'INIT' state.
 Also using the above definition we cannot guarantee that the inverted machine
 is actually the inverse of the input since the input may have pass through
 other states and during all of these states, the inverted machine will
 stay 'off'.
 
\end_layout

\begin_layout Standard
The above definition may be made more strict by tightening the definition
 of the off state:
\end_layout

\begin_layout LyX-Code
Inverted MACHINE input {
\end_layout

\begin_deeper
\begin_layout LyX-Code
on WHEN input == off; 
\end_layout

\begin_layout LyX-Code
off WHEN input == on;
\end_layout

\begin_layout LyX-Code
unknown DEFAULT;
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
This definition enables us to be more confident in claiming the machine
 to be an inversion but if the input machine has many other states we may
 have to deal with the `unknown' state in some way.
 In practice, the previous definition is quite practical and these subtle
 distinctions are not helpful to the modelling process.
\end_layout

\begin_layout Subsection
Transition statement
\end_layout

\begin_layout Standard
Transitions define how a system changes state based on the receipt of an
 event or command.
 Transitions can:
\end_layout

\begin_layout Itemize
be used to prevent arbitrary state changes
\end_layout

\begin_layout Itemize
can be guarded by requirements that must be met for the transtion to occur
\end_layout

\begin_layout Itemize
can define a command to execute when a machine is set into a state by another
 machine
\end_layout

\begin_layout Standard
The following Machine changes between a `ready' and `started' state when
 a start or stop command is received.
\end_layout

\begin_layout LyX-Code
StartStopTimer MACHINE {
\end_layout

\begin_deeper
\begin_layout LyX-Code
ready INITIAL; started STATE;
\end_layout

\begin_layout LyX-Code
COMMAND stop { timer := TIMER; } 
\end_layout

\begin_layout LyX-Code
COMMAND start { } 
\end_layout

\begin_layout LyX-Code
TRANSITION started TO ready ON stop; 
\end_layout

\begin_layout LyX-Code
TRANSITION ready TO started ON start; 
\end_layout

\end_deeper
\begin_layout LyX-Code
} 
\end_layout

\begin_layout Subsection
Event handlers (methods)
\end_layout

\begin_layout Standard
Event handlers are commands that execute when a machine changes state.
 Currently handlers are executed upon entry and exit of a state, they are
 defined using:
\end_layout

\begin_layout LyX-Code
ENTER state-name { actions }
\end_layout

\begin_layout Standard
and
\end_layout

\begin_layout LyX-Code
LEAVE state-name { actions }
\end_layout

\begin_layout Subsection
Commands
\end_layout

\begin_layout Standard
Commands are lists of actions that are executed in response to receipt of
 a message.
 While commands are being executed, the stable state evaluation for a machine
 are not executed.
 Commands may have an associated state that the machine moves to while executing
 the actions.
\end_layout

\begin_layout Standard
The mechanism for this will be to add clauses to identify timeouts or other
 conditions:
\end_layout

\begin_layout LyX-Code
COMMAND example { statements } ON ERROR message
\end_layout

\begin_layout Standard
or
\end_layout

\begin_layout LyX-Code
COMMAND example { statements } ON TIMEOUT message
\end_layout

\begin_layout Subsection
Exporting properties
\end_layout

\begin_layout Standard
A machine can export its properties for use by Modbus applications through
 use of the EXPORT statement...
\end_layout

\begin_layout Subsection
Lists
\end_layout

\begin_layout Standard
Machines can be grouped together into lists.
 Lists have some features and restrictions:
\end_layout

\begin_layout Itemize
machines may be placed on a list but every entry in the list must be unique,
 attempting to include an item a second time leads to undefined bahaviour
\end_layout

\begin_layout Itemize
messages sent to a list are also sent to all entries of the list
\end_layout

\begin_layout Itemize
entries of a list remain in the order they are added (ie., the INCLUDE statement
 adds an elment to the end of the list) unless the list order is changed
 by a SORT statement
\end_layout

\begin_layout Itemize
lists can be reordered by using a property of the entries as the sort key,
 by default the VALUE property is used
\end_layout

\begin_layout Itemize
lists entry states or properties can be packed into an binary value property
 using the BITSET FROM statement and can be restored using the SET LIST
 ENTRIES statement
\end_layout

\begin_layout Itemize
items can be tested to see if a list contains a reference to them (eg., my_list
 INCLUDES my_machine)
\end_layout

\begin_layout Itemize
set operations are available to load lists based on operations involving
 other lists
\end_layout

\begin_layout Subsection
Monitoring globals
\end_layout

\begin_layout Standard
Generally a Machine will only receive events from machines that are passed
 as parameters or that are included within the Machine.
 By using the GLOBAL keyword, a Machine can monitor state changes on other
 machines, not passed as parameters.
 By this technique, it is possible to avoid passing parameters to machines
 and to simply refer to all machines globally.
 This is probably fine for small systems but less practical for larger systems.
\end_layout

\begin_layout Subsection
References
\end_layout

\begin_layout Standard
The builtin machine, REFERENCE provides a way to link machines together.
 When an object is assigned to a reference, the reference enters the ASSIGNED
 state, when the reference is cleared, it enters the UNASSIGNED state.
 Other machines can detect these changes by listening for ASSIGNED_enter
 or UNASSIGNED_enter mesages.
 If an assignment is attempted to a non-existent machine any preexisting
 assignment is cleared and the new assignment fails.
\end_layout

\begin_layout Subsection
Conditions
\end_layout

\begin_layout Standard
Conditions are lists of boolean expressions that are generally used to determine
 the current state of various parts of the machine.
 Conditions are implemented by the use of separate state machines.
 that contain a state (normally called 'true') that indicates the condition
 is true and a state (normally called 'false') that is the default.
\end_layout

\begin_layout Subsection
Notes
\end_layout

\begin_layout Standard
An action is a list of steps, such that each step requests that a machine
 enters a state or waits for a message.
 Regardless of the action, there are two components: sending a message and
 waiting for a response.
 On receipt of the response, the action transitions to the next step in
 the list.
\end_layout

\begin_layout Standard
When a state change request is received, the transitions on the target machine
 are searched for an action that will satisfy the requested state change.
 That action causes a further sequence of actions to be queued by having
 the machine enter a substate with each action sending a message and waiting
 for a response.
 
\end_layout

\begin_layout Section
Machines
\end_layout

\begin_layout Subsection
Parts of a machine
\end_layout

\begin_layout Standard
Machines are the core of clockwork programming; they define a virtual representa
tion of the operation of real machines or processes and in so doing provide
 a correspondence between the state of the program and the state of the
 machinery in the real world.
\end_layout

\begin_layout Standard
The definition of a machine includes several sections:
\end_layout

\begin_layout Itemize
declaration and initialisation of properties (also called options)
\end_layout

\begin_layout Itemize
declaration of states
\end_layout

\begin_layout Itemize
definition of stable states
\end_layout

\begin_layout Itemize
definition of transitions
\end_layout

\begin_layout Itemize
definition of event handlers
\end_layout

\begin_layout Itemize
definition of commands
\end_layout

\begin_layout Itemize
export declarations
\end_layout

\begin_layout Standard
These sections are only for conceptual convenience; declarations and definitions
 can be freely intermixed but the order that stable states are declared
 is important.
 
\end_layout

\begin_layout Standard
To define a machine use:
\emph on
 class_name 
\emph default
MACHINE 
\emph on
parameter1, parameter2, ...
 
\emph default
{ } and place the definition between the braces.
 
\end_layout

\begin_layout Standard
To create an instance of a machine, use: 
\emph on
name
\emph default
 
\emph on
class_name
\emph default
 
\emph on
param1, param2, ...
 
\emph default
;.
 There can be any number of instances for a given machine definition.
 The trick is mostly to do with what goes between the braces.
\end_layout

\begin_layout Subsection
Components and scope
\end_layout

\begin_layout Standard
The language deals with Finite State Machines, which the language simply
 calls 'Machines' and their states.
 The program defines a machine as having certain states and provides conditions
 and scripts that can identify the current state and change states.
\end_layout

\begin_layout Standard
some predefined objects; Modules, Points, Machines, Values, Conditions and
 States.
 These objects may have parameters and may also have properties.
 Properties and parameters are distinguished as follows:
\end_layout

\begin_layout Itemize
properties have default values and do not have to be provided
\end_layout

\begin_layout Itemize
parameters generally refer to objects that the machine manipulates and serve
 to provide an internal alias for a globally defined object.
 Use of parameters provides for the reuse of machines for different parts
 of the system.
\end_layout

\begin_layout Subsection
Parameters
\end_layout

\begin_layout Standard
When a machine is instantiated, parameters are resolved by providing either
 a symbol name or a symbol value.
 The Machine Instance retains a list of ParameterReferences and for parameters
 passed by value, a local symbol table allocates a local name
\end_layout

\begin_layout Subsection
States
\end_layout

\begin_layout Standard
A state is defined by a particular configuration of inputs or execution
 of an action.
\end_layout

\begin_layout Subsection
Actions
\end_layout

\begin_layout Standard
An action is a sequence of steps that are executed in response to the receipt
 of a message, including steps taken dugin an entry function.
\end_layout

\begin_layout Subsection
Transitions
\end_layout

\begin_layout Standard
Transitions occur automatically when a machine is idle, when it detects
 a change of state.
 When a transition occurs:
\end_layout

\begin_layout Itemize
the timer is reset, 
\end_layout

\begin_layout Itemize
the state variable 'CURRENT' is updated
\end_layout

\begin_layout Itemize
a state change message is queued for delivery to interested parties
\end_layout

\begin_layout Itemize
the entry function for the state is executed
\end_layout

\begin_layout Subsection
Events
\end_layout

\begin_layout Standard
An event corresponds to the sending of a message.
 Examples of events include timers and changes in input levels or analogue
 or counter values.
 Timer events are intented to trigger reasonably precisely, based on a fixed
 time after the message was sent.
\end_layout

\begin_layout Subsection
Message Passing
\end_layout

\begin_layout Standard
Machines can send and receive messages directly, using the commands SEND
 and CALL and the handler RECEIVE or it can send messages indirectly by
 attempting to change the state of the target machine.
\end_layout

\begin_layout Subsubsection
RECEIVE and RECEIVE..FROM
\end_layout

\begin_layout Standard
Each machine can listen for messages from any entity it knows of.
 Messages are sent when entities change state or when a script deliberately
 sends one.
 To listen for a message, use:
\end_layout

\begin_layout Quotation
RECEIVE objname.message '{' actions '}'
\end_layout

\begin_layout Standard
or
\end_layout

\begin_layout Quotation
RECEIVE message FROM objname '{' actions '}'
\end_layout

\begin_layout Standard
This identifies the sending entity from its local name and registers a listener
 for the 
\emph on
entiyname_statename_enter
\emph default
 message.
 In a future release, the current machine will also registered as a dependant
 of the sender.
 Currently, messages are only received from parameters, local instances
 and machine instances that are specifically listed in GLOBALS.
\end_layout

\begin_layout Subsubsection
SEND and SEND..TO
\end_layout

\begin_layout Subsubsection
CALL
\end_layout

\begin_layout Standard
The CALL statement acts like theSEND except that the statement hangs and
 waits for a response from the target.
 There are a few forms:
\end_layout

\begin_layout Standard
CALL command
\end_layout

\begin_layout Standard
CALL command ON ERROR CALL command
\end_layout

\begin_layout Standard
CALL command, EXECUTE command WHEN predicate
\end_layout

\begin_layout Subsection
Exceptions
\end_layout

\begin_layout Standard
[Note: not implemented]An exception is a message sent using the 'THROW'
 command.
 It is similar to a message sent with 'SEND' except that there is no requirement
 that there is a machine listening for the message.
 Messages that are thrown are caught using the 'CATCH' command.
\end_layout

\begin_layout Chapter
Statements
\end_layout

\begin_layout Standard
This chapter provides examples of common statements and clauses used in
 clockwork.
 (TODO)
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="36" columns="2">
<features islongtable="true" longtabularalignment="center">
<column alignment="left" valignment="top" width="9cm">
<column alignment="left" valignment="top" width="6cm">
<row endhead="true">
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
Statement
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
Comment
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
y := ABS x
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
if x is negative, y becomes -x otherwise, y becomes x.
 If x is a string, y becomes zero
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
LOG "x: " + x + " y:" + y
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
the values of x and y as strings are concatenated with the other strings
 to produce a single string that is then logged to standard out
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
myOnTime := myOnTime + TIMER
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
the current state time is added to the property: myOnTime
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
start_time := NOW
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
the current time in milliseconds
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
IF (start_time == 0) { a := b }
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
example simple if
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
WAIT 1000;
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
the machine will halt execution for 1 second and will not process messages
 received or check for state changes during this time.
 Execution of the current block continues after 1 second.
 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
SEND hello TO SELF
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
the message is queued for execution and will start once all of the actions
 in the current block has completed.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
raw := TAKE FIRST FROM queue;
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
the first item in the list named queue is removed from the list and placed
 into raw
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
tmp := COPY `[0-9][0-9]+` FROM raw;
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
the first sequence of digits in raw is copied into tmp
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
n_tmp := "1" + tmp;
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
tmp is appended as a string to the string 
\begin_inset Quotes eld
\end_inset

1
\begin_inset Quotes erd
\end_inset

 and the result placed into n_tmp
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
n_tmp := COPY ALL `[0-9]` FROM tmp;
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
all of the digits in tmp are copied into n_tmp
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
Weight := 0 + n_tmp
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
n_tmp as an integer is added to zero and the result placed into Weight
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
CLEAR test;
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
all entries are removed from the list named test
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
COPY ALL FROM source TO dest;
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
all items in the list named source to the list named dest
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
ADD f1 BEFORE FIRST OF test;
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
the property or machine named f1 is placed before the first item in the
 list named test
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
ADD f1 AFTER LAST OF test
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
the property or machine named f1 is placed after the last item in the list
 named test
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
MOVE ITEMS 2 TO 3 OF test TO work
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
the second and third items of the list named test are removed and added
 to the end of the list named work
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
x := TAKE LAST FROM test
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
the last element of the list test is removed and placed into the property
 x.
 It is possible in this case for x to be holding a machine reference but
 the only thing that can be done with this value it to place it onto another
 list
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
WAITFOR test IS off
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
the current machine pauses execution and waits until the machine named test
 enters the off state.
 During this time, the current machine does not process messages or check
 for automatic state changes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
DISABLE script
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
the machine named script becomes disabled
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
x.a := (Zone + -1) % 9 - (Location - 1) * 3 + 1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
the property a in machine x is set to the result of the given calculation
 (% is the modulus operator)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
LOG "a: " + FORMAT a WITH "%04d"
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
the property a is converted to a string with 4 digits and leading zeros
 and appended to 
\begin_inset Quotes eld
\end_inset

a: 
\begin_inset Quotes eld
\end_inset

 before being logged to standard out
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
TRANSITION on TO off ON next
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
when the message 'next' is received, the machine will leave the on state
 and go to the off state.
 The message will be ignored if the machine is not in the on state
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
RECEIVE in.on_enter { SEND next TO SELF; }
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
when the machine named in enters the on state, send the message 
\begin_inset Quotes eld
\end_inset

next
\begin_inset Quotes erd
\end_inset

 to the current machine.
 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
val := one | six
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
the property one is bitwised or'ed with the property six and the result
 placed in val
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
one WHEN BITSET FROM a == 1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a must be a list in which case all items in a are interpreted as boolean
 flags where the state 'on' represents one and all other states represent
 zero.
 These flags are collected together in order to form an integer value from
 a set of bits
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
on WHEN SELF IS off AND TIMER >= 1000 || SELF IS on AND TIMER < 1000;
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
the cuttent machine will move to the on state if it is off and has been
 off for at least 1 second or stay in the on state if it is on and hasn't
 been on for a second yet
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
RECEIVE calc { a := NOW; }
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
executes the action to assign NOW to a when the message 'calc' is recieved
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
SEND calc TO worker
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
sends the message 'calc' to a machine names worker
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
a FLAG(val:1);
\end_layout

\begin_layout Plain Layout

\family typewriter
\size footnotesize
b FLAG(val:2);
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
instantiates a machine named 'a' that uses the behaviour defined for FLAG
 and addes a property 'val' within initial value
\begin_inset space ~
\end_inset

1 and instantiates a machine named 'b' the same way ...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
abc LIST a,b;
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
instantiates a list called 'abc' with two machines, a and b initially
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
COPY ALL FROM list TO copied WHERE list.ITEM.val == 1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
copies all machines in the list named list to the list named copied where
 the condition is true that the machine to be copied has a property 'val'
 with value
\begin_inset space ~
\end_inset

1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
COPY ALL FROM data TO result SELECT USING sel WHERE data.ITEM.val == sel.ITEM.x
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
joins two lists, 'data' and 'sel' where the val property of items in data
 match the x property of items in sel
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
off WHEN af IS on;
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
sets the current machine to off when the machine named 'af' is on
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
stable WHEN x.VALUE == last.VALUE; 
\end_layout

\begin_layout Plain Layout

\family typewriter
\size footnotesize
recalculate DEFAULT;

\end_layout

\begin_layout Plain Layout

\family typewriter
\size footnotesize
ENTER recalculate { last := x }
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a pair or rules cause a machine to recalculate whenever a value in x changes.
 Inside the handler for recalculate, the value in x is copied into last
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Chapter
Subtleties
\end_layout

\begin_layout Subsection
Enabling and disabling machines
\end_layout

\begin_layout Standard
Machines in clockwork may be prevented from operating by disabling them.
 Messages sent to disabled machines are silently ignored and attempts to
 set the state of a disabled machine triggers an exception.
 TBD more information about interactions with disabled machines.
\end_layout

\begin_layout Subsection
Controlling startup
\end_layout

\begin_layout Standard
When the clockwork environment starts, all machines initially disabled and
 are enabled depending on the following rules:
\end_layout

\begin_layout Standard
if the application program implements a machine with the class 'STARTUP',
 only that machine is enabled and the entire startup process is left to
 application control.
\end_layout

\begin_layout Standard
if there is no instance of a 'STARTUP' machine machines that have a property:
 'startup_enabled' with a value of false are not enabled and all other machines
 are enabled.
\end_layout

\begin_layout Standard
The system attempts to start machines in order such that machines passed
 as paremeters to other machines are enabled first.
\end_layout

\begin_layout Standard
Machines that include a 'DEPENDS ON' clause can only enabled when the named
 machine has been enabled.
 If the named machine does not exist it is not possible to enable the dependent
 machines.
 In the case where the application does not provide a STARTUP machine, when
 the machines that are the object of a DEPENDS ON clause are enabled or
 disabled those machines that depend on them are automatically enabled or
 disabled.
\end_layout

\begin_layout Section
Details
\end_layout

\begin_layout Chapter
Vocabulary
\end_layout

\begin_layout Standard
Within the program text, reserved words are presented in all capitals to
 distinguish them from user defined values.
 The language is case sensitive.
\end_layout

\begin_layout Subsection
Glossary of Reserved Words 
\end_layout

\begin_layout Description
16BIT defines an exported modbus property as a 16bit integer
\end_layout

\begin_layout Description
32BIT defines an exported modbus property as a 32bit integer
\end_layout

\begin_layout Description
ABORT aborts the current action with an error status
\end_layout

\begin_layout Description
ABS returns the absolute value of a number
\end_layout

\begin_layout Description
ADD adds an item to a list in a specific position
\end_layout

\begin_layout Description
AFTER a qualified used when adding an item to a list indicates the item
 will be after the given item
\end_layout

\begin_layout Description
ALL used with COPY and EXTRACT to collect all matches from a property
\end_layout

\begin_layout Description
AND (also &&) used in predicates (state rules) and boolean expressions to
 join two boolean clauses
\end_layout

\begin_layout Description
ANY used when checking the state of all items in LISTs 
\end_layout

\begin_layout Description
ARE used when checking the state of all items in LISTs
\end_layout

\begin_layout Description
AS used for type convertion to STRING, FLOAT or INTEGER
\end_layout

\begin_layout Description
ASC used to define an ascending sort order (alternate form of ASCENDING)
\end_layout

\begin_layout Description
ASCENDING used to define an ascending sort order
\end_layout

\begin_layout Description
ASSIGN used to set a reference value
\end_layout

\begin_layout Description
AT used within a RESUME clause to resume a machine at a named state
\end_layout

\begin_layout Description
BECOMES name of the assignment operator (:=)
\end_layout

\begin_layout Description
BEFORE used when insterting items into a list
\end_layout

\begin_layout Description
BETWEEN used to check whether a value is in a given range
\end_layout

\begin_layout Description
BITSET used when converting between a LIST and a number representation of
 a set of boolean flags
\end_layout

\begin_layout Description
BY used as a conjunction in SORT..BY and INC/DEC BY statements
\end_layout

\begin_layout Description
CALL sends a message to a given machine and waits for completion of handlers
 attached to that message.
\end_layout

\begin_layout Description
CATCH defines an exception handling action
\end_layout

\begin_layout Description
CHANGING used to test whether a machine is changing state
\end_layout

\begin_layout Description
CHANNEL defines a connection between one clockwork program and another or
 between a clockwork program and external tool
\end_layout

\begin_layout Description
CLASS used to get the name of the definition of a machine
\end_layout

\begin_layout Description
CLEAR resets a LIST or REFERENCE
\end_layout

\begin_layout Description
COLLECT used for collecting data from an external source
\end_layout

\begin_layout Description
COMBINATION used to form the union of two sets
\end_layout

\begin_layout Description
COMMAND defines an action that handles a message arriving at a machine from
 a SEND or CALL action
\end_layout

\begin_layout Description
COMMANDS used in defining an interface for a CHANNEL
\end_layout

\begin_layout Description
COMMON used to collect common elements in two lists
\end_layout

\begin_layout Description
CONDITION defines a condition object that has a value of true or false depending
 on the state of an expression
\end_layout

\begin_layout Description
CONSTANT a predefined machine class that acts like a constant from a syntactic
 viewpoint
\end_layout

\begin_layout Description
COPY used to collect items from a list and put them into another list or
 to copy substrings matching a pattern from a given property
\end_layout

\begin_layout Description
COUNT used to find how many items in a list
\end_layout

\begin_layout Description
CREATE creates a list with some elements of another list
\end_layout

\begin_layout Description
DEC decrement a property by an amount
\end_layout

\begin_layout Description
DEFAULT defined an always-true rule that is evaluated last in a machines
 automatic states list
\end_layout

\begin_layout Description
DESC used to specify a descending sort order (alternate name for DESCENDING)
 
\end_layout

\begin_layout Description
DESCENDING used to specify a descending sort ordeer
\end_layout

\begin_layout Description
DIFFERENCE used when copying members from a list that are unique to that
 list compared to another
\end_layout

\begin_layout Description
DISABLE used to make a machine unable to respond to requests to change state
 or process commands.
 Properties of a disabled machine can still be changed.
 The machine stays in the state it was is when it was disabled 
\end_layout

\begin_layout Description
DISABLE used to stop a machine from further processing until enabled or
 resumed
\end_layout

\begin_layout Description
DISABLED used to test whether a machine is disabled
\end_layout

\begin_layout Description
DURING used to define a state that should be used while a given action is
 being excuted in response to a specific message, after the completion of
 the action, the machines automatic state changes or transitions will execute.
 If there are no automatic state rules or transitions, the machine will
 stay in the given state.
\end_layout

\begin_layout Description
ELSE marks the beginning of the code that is executed when the IF condition
 evaluates to false
\end_layout

\begin_layout Description
ENABLE makes a machine able to respond to requests and changes state.
 The machine enters its initial state and executes the initial state entry
 method.
 The leave event to the previous state is also executed and the message
 is sent to dependent machines.
\end_layout

\begin_layout Description
ENABLED used to test whether a machine is enabled
\end_layout

\begin_layout Description
ENTER used to define an action that executes when a machine starts to enter
 a state
\end_layout

\begin_layout Description
ENTRIES used in the conversion between lists and numeric representations
 of a set of booleans
\end_layout

\begin_layout Description
EQ the name of the '==' operator
\end_layout

\begin_layout Description
ERROR used to define what happens if an action experiences an error or timeout
\end_layout

\begin_layout Description
ERRORS used when indicating that errors should be ignored for a given action
\end_layout

\begin_layout Description
EXECUTE extends the definition of a stable state to specify a command that
 should be executed when a special sub-condition becomes active.
\end_layout

\begin_layout Description
EXISTS used to test if a machine is defined
\end_layout

\begin_layout Description
EXPORT used when exporting properties or options to modbus or humid
\end_layout

\begin_layout Description
EXPORTS used when defining a channel interface to indicate whether exported
 options are passed to the channel
\end_layout

\begin_layout Description
EXTENDS used for type extension for channels
\end_layout

\begin_layout Description
EXTRACT used with regular expressions to extract subexpressions into options
\end_layout

\begin_layout Description
FAILURE used when defining what to do if a transition fails
\end_layout

\begin_layout Description
FIND returns a list of objects that are in the given state, options may
 be added to restrict the range of items found [not implemented]
\end_layout

\begin_layout Description
FIRST indicates the first item in a list
\end_layout

\begin_layout Description
FLAG a builtin machine definition with an on and off state, commonly used
 as a boolean indicator
\end_layout

\begin_layout Description
FLOAT declares a variable to have a floating point value
\end_layout

\begin_layout Description
FLOAT32 declares the floating point format used when a float value is exported
\end_layout

\begin_layout Description
FOREACH performs an operation for each object within the given list that
 are in a particular state [not implemented]
\end_layout

\begin_layout Description
FORMAT used when converting a value to a string
\end_layout

\begin_layout Description
FROM used in several expressions where a value is bing generated or copied
 from another
\end_layout

\begin_layout Description
GE the name of the '>=' symbol
\end_layout

\begin_layout Description
GLOBAL used to introduce a dependency with an instance of a machine that
 is not directly connected
\end_layout

\begin_layout Description
GLOBALS lists machines, external to the current class that the current machine
 is monitoring.
 State changes on the machines listed as GLOBAL cause a reevaluation of
 stable states and generate events that can be received.
\end_layout

\begin_layout Description
GT the name of the '>' operator
\end_layout

\begin_layout Description
IDENTIFIER provides a unique id for a channel
\end_layout

\begin_layout Description
IF used within operations (Commands and Enter functions) to provide for
 conditional behaviour
\end_layout

\begin_layout Description
IGNORES used in a channel interface definition to desribe machines that
 the channel ignores
\end_layout

\begin_layout Description
IN used when searching for an item in a list, replacing a pattern within
 a string, copying items from lists and similar actions
\end_layout

\begin_layout Description
INC increments an option by an amount
\end_layout

\begin_layout Description
INCLUDE used to add a machine to a list
\end_layout

\begin_layout Description
INCLUDES used in testing whether a machine is in a list
\end_layout

\begin_layout Description
INDEX identified the position (numbered from zero) of an item in a list,
 
\end_layout

\begin_layout Description
INIT a predefined state that statemachines enter as soon as they are enabled.
\end_layout

\begin_layout Description
INITIAL defines a state as the state to use for the initial state of the
 machine.
\end_layout

\begin_layout Description
INTEGER used in converting a value to an integer
\end_layout

\begin_layout Description
INTERFACE introduces a new interface definition, used by a CHANNEL
\end_layout

\begin_layout Description
ITEM used as a proxy name for the item that a reference is pointing to or
 the current item within a list search
\end_layout

\begin_layout Description
ITEMS used when adding or removing machines to/from a list
\end_layout

\begin_layout Description
KEY used to define a unique secret for a channel
\end_layout

\begin_layout Description
LAST refers to the last element of a list
\end_layout

\begin_layout Description
LE the name of the '<=' symbol
\end_layout

\begin_layout Description
LEAVE declares an action to be executed when a machine leaves a given state
\end_layout

\begin_layout Description
LENGTH defines an action to be executed when a machine leaves a given state
\end_layout

\begin_layout Description
LINE 
\end_layout

\begin_layout Description
LINKED used in an INTERFACE to indicate that machines dependent on another
 are to be passed through a channel
\end_layout

\begin_layout Description
LOCAL defines an option that does not generate property change messages
 when its value changes, used for temporary variables in a calculation
\end_layout

\begin_layout Description
LOCK prevents a machine from being changed by other external machines until
 the machine that locked it unlocks it again, used as a synchronisation
 mechanism to prevent, for example, multiple machines simultaneously changing
 the state of a machine.
\end_layout

\begin_layout Description
LOCK provides a way to mark a protected section to prevent, for example,
 multiple machines simultaneously changing the state of a machine.
\end_layout

\begin_layout Description
LOG places a message in the application output and in the message log accessible
 from iosh with the MESSAGES command
\end_layout

\begin_layout Description
LT the name of the '<' symbol
\end_layout

\begin_layout Description
MACHINE defines a programmed component within the system.
 All control functionality is implemented within these objects.
 Machines are based on finite statemachine concept and include both monitoring
 (automatic state switching) and control (forced state changes to cause
 actions).
\end_layout

\begin_layout Description
MACHINES used when defining the machines that are passed through a channel
\end_layout

\begin_layout Description
MATCHES indicates whether a string mathes a pattern
\end_layout

\begin_layout Description
MATCHES used in an expression to test for a property matching a given pattern
\end_layout

\begin_layout Description
MATCHING used to define selectors for machines that are passed through a
 channel
\end_layout

\begin_layout Description
MAX the largest value in a list
\end_layout

\begin_layout Description
MEAN the arithmetic mean value of items in a list
\end_layout

\begin_layout Description
MIN the arithmetic minimum value of items in a list
\end_layout

\begin_layout Description
MODBUS used in defining selectors for machines that are passed through a
 channel
\end_layout

\begin_layout Description
MODULE declares use of an EtherCAT IO Module
\end_layout

\begin_layout Description
MODULES begins a section for declaration of EtherCAT IO Modules
\end_layout

\begin_layout Description
MONITORS used in defining selectors for machines that are passed through
 a channel
\end_layout

\begin_layout Description
MOVE takes an item from a list and puts it into another
\end_layout

\begin_layout Description
NAME used when defining selectors for machines that are passed through a
 channel 
\end_layout

\begin_layout Description
NE the name of the '!=' operator
\end_layout

\begin_layout Description
NOT a prefix operator that inverts a boolean result, such as in the predicate
 of automatic state rules
\end_layout

\begin_layout Description
NUMBER
\end_layout

\begin_layout Description
OF
\end_layout

\begin_layout Description
ON
\end_layout

\begin_layout Description
OPTION defines an option (also called 'property') name and value
\end_layout

\begin_layout Description
OR (also ||) used to join expressions within a condition
\end_layout

\begin_layout Description
PERSISTENT a property that indicates that propertye changes on this machine
 will be published.
 Machines marked as persistent are no longer automatically enabled on startup.
\end_layout

\begin_layout Description
PLUGIN
\end_layout

\begin_layout Description
POINT refers to an addressable port within a module or a builtin machine
 with that name (see Section [subsec:Builtin-classes])
\end_layout

\begin_layout Description
PROPERTIES part of the COPY PROPERTIES ...
 statement
\end_layout

\begin_layout Description
PROPERTY indicates that the following symbol is used as the name of a property
 containing a value, rather than being a value
\end_layout

\begin_layout Description
PROPERTY_CHANGES indicates that a channel emits property changes
\end_layout

\begin_layout Description
PUBLISHER indicates in a channel interface that the channel is a publisher
 (sends state and value changes via publish/subscribe)
\end_layout

\begin_layout Description
PUSH adds an item to a list
\end_layout

\begin_layout Description
QUOTE 
\end_layout

\begin_layout Description
RAISE send a message that any machine may catch.
 It is an error if a message is raised but not caught.
 [not implemented]
\end_layout

\begin_layout Description
READONLY used in an EXPORT specification to mark the property as read only
\end_layout

\begin_layout Description
READWRITE used in an EXPORT specification to mark the property as read/write
\end_layout

\begin_layout Description
RECEIVE indicates that a machine should be informed when a specific object
 sends a particular message.
 The RECEIVE statement has an associated set of actions that are acted when
 the event is collected.
\end_layout

\begin_layout Description
RECEIVES 
\end_layout

\begin_layout Description
REPLACE 
\end_layout

\begin_layout Description
REPORTS
\end_layout

\begin_layout Description
REQUIRES indicates that the associated condition must evaluate to True in
 order that the transition can occur or that a command can be executed [not
 implemented]
\end_layout

\begin_layout Description
RESULT the returned value after an expression has been evaluated [not implemente
d]
\end_layout

\begin_layout Description
RESUME resumes execution of the disabled machine from the beginning of its
 current state
\end_layout

\begin_layout Description
RETURN performs a normal exit from an action without setting an error (compare
 to ABORT)
\end_layout

\begin_layout Description
ROUTE redirects an incoming message
\end_layout

\begin_layout Description
SELECT 
\end_layout

\begin_layout Description
SELF used in expressions to refer 
\end_layout

\begin_layout Description
SEND is used to send a message to a machine, this message must be captured
 by the machine, using a RECEIVE statement
\end_layout

\begin_layout Description
SENDS 
\end_layout

\begin_layout Description
SEPARATOR 
\end_layout

\begin_layout Description
SET causes a machine to move to a given state after executing the optional
 command associated with the transition
\end_layout

\begin_layout Description
SHARES defines a list of machines that shared on a channel.
 Shared machines can be updated by both ends of a channel
\end_layout

\begin_layout Description
SHUTDOWN cause the clockwork daemon to exit
\end_layout

\begin_layout Description
SIZE provides the number of items in a list
\end_layout

\begin_layout Description
SORT used to sort a list of machines based on the value of a property or
 a list of value by the value
\end_layout

\begin_layout Description
SOURCE is a variable that holds a reference to the object that send the
 current message or issued the current command [not implemented]
\end_layout

\begin_layout Description
STATE defines a state name so that this state can be used in a transition
 or can be set by other machines.
\end_layout

\begin_layout Description
STATE_CHANGES indicates in an interface definition whether state changes
 will be sent through the channel
\end_layout

\begin_layout Description
SUM calculates the arithmetic sum of the items in a list
\end_layout

\begin_layout Description
TAG links a FLAG to a sub-condition on a stable state so that the FLAG is
 automatically turned on and off to trak whether the subcondition is true
 or not.
\end_layout

\begin_layout Description
TAKE removes one or more items from a list
\end_layout

\begin_layout Description
THEN marks the beginning of the code that is executed when the IF condition
 evaluates to true
\end_layout

\begin_layout Description
THROTTLE indicates that a channel should limit the rate at which it propagates
 state transitions or value changes
\end_layout

\begin_layout Description
THROW stops execution of the current action and sends a given message to
 be caught by a related CATCH action
\end_layout

\begin_layout Description
TIMEOUT defines an expected duration for the given statement to complete.
 If the statement doesn't complete within the given time an error action
 is executed in the same was as if a THROW had occurred
\end_layout

\begin_layout Description
TIMER a numeric value in milliseconds giving the amount of time a given
 machine has been in its current state
\end_layout

\begin_layout Description
TO used within a transition to indicate the destination state, used within
 a message operation to indicate the target of the message
\end_layout

\begin_layout Description
TRANSITION describes the command that can be used to move the machine from
 one state to another
\end_layout

\begin_layout Description
TRIM not implemented
\end_layout

\begin_layout Description
UNLOCK reverses the effect of LOCK, to permit other instances execute code
 in a critical section.
\end_layout

\begin_layout Description
UPDATES used in a channel interface, to indicate machines that are updated
 by the channel
\end_layout

\begin_layout Description
USING as part of the transition statement, the Using clause indicates the
 command that is used for the transition
\end_layout

\begin_layout Description
VARIABLE a predefined machine class that is persistent and acts like a variable
 from a syntactic viewpoint
\end_layout

\begin_layout Description
VERSION used in a channel interface to identify its version
\end_layout

\begin_layout Description
WAIT pauses execution of the current method for the set amount of time
\end_layout

\begin_layout Description
WAITFOR pauses execution of the current method until the given machine enters
 the given state
\end_layout

\begin_layout Description
WHEN defines a set of conditions that indicate a machine is in a particular,
 stable state.
 These conditions are not evaluated when the machine is in a transitional
 state.
\end_layout

\begin_layout Description
WHERE used for bulk enable/disable/resume operations as well as in selectors
 when copying items from list and also used in interface definitions
\end_layout

\begin_layout Description
WITH used in a variety of clauses such as channel interface definitions
 or when building a value from another or from a list.
 Also 
\end_layout

\begin_layout Description
WITHIN used to indicate a command that can only be executed when the machine
 is in a given state
\end_layout

\begin_layout Section
Properties
\end_layout

\begin_layout Standard
Machine instances share some standard properties
\end_layout

\begin_layout Description
current the current state of the instance
\end_layout

\begin_layout Description
referers a list of machines that refer to this machine
\end_layout

\begin_layout Description
references a list of machines this one refers to
\end_layout

\begin_layout Description
sends a list of messages this machine sends
\end_layout

\begin_layout Description
receives a list of messages this machine receives
\end_layout

\begin_layout Subsection
Builtin classes
\begin_inset CommandInset label
LatexCommand label
name "subsec:Builtin-classes"

\end_inset


\end_layout

\begin_layout Standard
Builtin classes such as FLAG and BOOLEAN are readily implemented using the
 language itself.
 The POINT class, however is special as it provides an interface to hardware.
 Integers are currnetly implemented through properties.
\end_layout

\begin_layout Description
VARIABLE
\end_layout

\begin_layout Description
MODULE
\end_layout

\begin_layout Description
CONSTANT
\end_layout

\begin_layout Description
FLAG two state machine with states 'on' and 'off'
\end_layout

\begin_layout Description
POINT a machine that links to a IO Point or a digital value accessible through
 the Internet of Things protocol.
\end_layout

\begin_layout Description
PUBLISHER a machine that publishes changes to its 'message' property to
 Internet Of Things brokers using its 'topic' property for the IoT topic.
\end_layout

\begin_layout Description
SUBSCRIBER a machine that subscribes to messages from Internet Of Things
 brokers to update its 'message' property when changes occur on the topic
 named in its 'topic' property.
\end_layout

\begin_layout Standard
(...TODO)
\end_layout

\begin_layout Section
Syntax
\end_layout

\begin_layout Standard
(TODO)
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
program & = & \mathit{definition}\,program\,|\,Ã\\
\mathcal{\mathit{definition}} & = & name\,object\,parameterlist\\
parameters & = & parameter\,|\,parameter\,','\,parameter\\
parameter & = & value\,parameter\,|\,Ã
\end{eqnarray*}

\end_inset


\end_layout

\end_body
\end_document
